// Code generated by Prisma (prisma@1.21.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  area: (where?: AreaWhereInput) => Promise<boolean>;
  city: (where?: CityWhereInput) => Promise<boolean>;
  collegeEntranceExam: (
    where?: CollegeEntranceExamWhereInput
  ) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  family: (where?: FamilyWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  major: (where?: MajorWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  province: (where?: ProvinceWhereInput) => Promise<boolean>;
  regStatus: (where?: RegStatusWhereInput) => Promise<boolean>;
  school: (where?: SchoolWhereInput) => Promise<boolean>;
  schoolEdu: (where?: SchoolEduWhereInput) => Promise<boolean>;
  street: (where?: StreetWhereInput) => Promise<boolean>;
  university: (where?: UniversityWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  village: (where?: VillageWhereInput) => Promise<boolean>;
  work: (where?: WorkWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  area: (where: AreaWhereUniqueInput) => AreaPromise;
  areas: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Area>;
  areasConnection: (
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AreaConnectionPromise;
  city: (where: CityWhereUniqueInput) => CityPromise;
  cities: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<City>;
  citiesConnection: (
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CityConnectionPromise;
  collegeEntranceExam: (
    where: CollegeEntranceExamWhereUniqueInput
  ) => CollegeEntranceExamPromise;
  collegeEntranceExams: (
    args?: {
      where?: CollegeEntranceExamWhereInput;
      orderBy?: CollegeEntranceExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CollegeEntranceExam>;
  collegeEntranceExamsConnection: (
    args?: {
      where?: CollegeEntranceExamWhereInput;
      orderBy?: CollegeEntranceExamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CollegeEntranceExamConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Company>;
  companiesConnection: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompanyConnectionPromise;
  family: (where: FamilyWhereUniqueInput) => FamilyPromise;
  families: (
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Family>;
  familiesConnection: (
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FamilyConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Location>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnectionPromise;
  major: (where: MajorWhereUniqueInput) => MajorPromise;
  majors: (
    args?: {
      where?: MajorWhereInput;
      orderBy?: MajorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Major>;
  majorsConnection: (
    args?: {
      where?: MajorWhereInput;
      orderBy?: MajorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MajorConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonPromise;
  persons: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Person>;
  personsConnection: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PersonConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  province: (where: ProvinceWhereUniqueInput) => ProvincePromise;
  provinces: (
    args?: {
      where?: ProvinceWhereInput;
      orderBy?: ProvinceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Province>;
  provincesConnection: (
    args?: {
      where?: ProvinceWhereInput;
      orderBy?: ProvinceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProvinceConnectionPromise;
  regStatus: (where: RegStatusWhereUniqueInput) => RegStatusPromise;
  regStatuses: (
    args?: {
      where?: RegStatusWhereInput;
      orderBy?: RegStatusOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<RegStatus>;
  regStatusesConnection: (
    args?: {
      where?: RegStatusWhereInput;
      orderBy?: RegStatusOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RegStatusConnectionPromise;
  school: (where: SchoolWhereUniqueInput) => SchoolPromise;
  schools: (
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<School>;
  schoolsConnection: (
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SchoolConnectionPromise;
  schoolEdu: (where: SchoolEduWhereUniqueInput) => SchoolEduPromise;
  schoolEdus: (
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SchoolEdu>;
  schoolEdusConnection: (
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SchoolEduConnectionPromise;
  street: (where: StreetWhereUniqueInput) => StreetPromise;
  streets: (
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Street>;
  streetsConnection: (
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StreetConnectionPromise;
  university: (where: UniversityWhereUniqueInput) => UniversityPromise;
  universities: (
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<University>;
  universitiesConnection: (
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UniversityConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  village: (where: VillageWhereUniqueInput) => VillagePromise;
  villages: (
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Village>;
  villagesConnection: (
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VillageConnectionPromise;
  work: (where: WorkWhereUniqueInput) => WorkPromise;
  works: (
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Work>;
  worksConnection: (
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WorkConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createArea: (data: AreaCreateInput) => AreaPromise;
  updateArea: (
    args: { data: AreaUpdateInput; where: AreaWhereUniqueInput }
  ) => AreaPromise;
  updateManyAreas: (
    args: { data: AreaUpdateManyMutationInput; where?: AreaWhereInput }
  ) => BatchPayloadPromise;
  upsertArea: (
    args: {
      where: AreaWhereUniqueInput;
      create: AreaCreateInput;
      update: AreaUpdateInput;
    }
  ) => AreaPromise;
  deleteArea: (where: AreaWhereUniqueInput) => AreaPromise;
  deleteManyAreas: (where?: AreaWhereInput) => BatchPayloadPromise;
  createCity: (data: CityCreateInput) => CityPromise;
  updateCity: (
    args: { data: CityUpdateInput; where: CityWhereUniqueInput }
  ) => CityPromise;
  updateManyCities: (
    args: { data: CityUpdateManyMutationInput; where?: CityWhereInput }
  ) => BatchPayloadPromise;
  upsertCity: (
    args: {
      where: CityWhereUniqueInput;
      create: CityCreateInput;
      update: CityUpdateInput;
    }
  ) => CityPromise;
  deleteCity: (where: CityWhereUniqueInput) => CityPromise;
  deleteManyCities: (where?: CityWhereInput) => BatchPayloadPromise;
  createCollegeEntranceExam: (
    data: CollegeEntranceExamCreateInput
  ) => CollegeEntranceExamPromise;
  updateCollegeEntranceExam: (
    args: {
      data: CollegeEntranceExamUpdateInput;
      where: CollegeEntranceExamWhereUniqueInput;
    }
  ) => CollegeEntranceExamPromise;
  updateManyCollegeEntranceExams: (
    args: {
      data: CollegeEntranceExamUpdateManyMutationInput;
      where?: CollegeEntranceExamWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCollegeEntranceExam: (
    args: {
      where: CollegeEntranceExamWhereUniqueInput;
      create: CollegeEntranceExamCreateInput;
      update: CollegeEntranceExamUpdateInput;
    }
  ) => CollegeEntranceExamPromise;
  deleteCollegeEntranceExam: (
    where: CollegeEntranceExamWhereUniqueInput
  ) => CollegeEntranceExamPromise;
  deleteManyCollegeEntranceExams: (
    where?: CollegeEntranceExamWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (
    args: { data: CompanyUpdateInput; where: CompanyWhereUniqueInput }
  ) => CompanyPromise;
  updateManyCompanies: (
    args: { data: CompanyUpdateManyMutationInput; where?: CompanyWhereInput }
  ) => BatchPayloadPromise;
  upsertCompany: (
    args: {
      where: CompanyWhereUniqueInput;
      create: CompanyCreateInput;
      update: CompanyUpdateInput;
    }
  ) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createFamily: (data: FamilyCreateInput) => FamilyPromise;
  updateFamily: (
    args: { data: FamilyUpdateInput; where: FamilyWhereUniqueInput }
  ) => FamilyPromise;
  updateManyFamilies: (
    args: { data: FamilyUpdateManyMutationInput; where?: FamilyWhereInput }
  ) => BatchPayloadPromise;
  upsertFamily: (
    args: {
      where: FamilyWhereUniqueInput;
      create: FamilyCreateInput;
      update: FamilyUpdateInput;
    }
  ) => FamilyPromise;
  deleteFamily: (where: FamilyWhereUniqueInput) => FamilyPromise;
  deleteManyFamilies: (where?: FamilyWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => LocationPromise;
  updateManyLocations: (
    args: { data: LocationUpdateManyMutationInput; where?: LocationWhereInput }
  ) => BatchPayloadPromise;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createMajor: (data: MajorCreateInput) => MajorPromise;
  updateMajor: (
    args: { data: MajorUpdateInput; where: MajorWhereUniqueInput }
  ) => MajorPromise;
  updateManyMajors: (
    args: { data: MajorUpdateManyMutationInput; where?: MajorWhereInput }
  ) => BatchPayloadPromise;
  upsertMajor: (
    args: {
      where: MajorWhereUniqueInput;
      create: MajorCreateInput;
      update: MajorUpdateInput;
    }
  ) => MajorPromise;
  deleteMajor: (where: MajorWhereUniqueInput) => MajorPromise;
  deleteManyMajors: (where?: MajorWhereInput) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (
    args: { data: PersonUpdateInput; where: PersonWhereUniqueInput }
  ) => PersonPromise;
  updateManyPersons: (
    args: { data: PersonUpdateManyMutationInput; where?: PersonWhereInput }
  ) => BatchPayloadPromise;
  upsertPerson: (
    args: {
      where: PersonWhereUniqueInput;
      create: PersonCreateInput;
      update: PersonUpdateInput;
    }
  ) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProvince: (data: ProvinceCreateInput) => ProvincePromise;
  updateProvince: (
    args: { data: ProvinceUpdateInput; where: ProvinceWhereUniqueInput }
  ) => ProvincePromise;
  updateManyProvinces: (
    args: { data: ProvinceUpdateManyMutationInput; where?: ProvinceWhereInput }
  ) => BatchPayloadPromise;
  upsertProvince: (
    args: {
      where: ProvinceWhereUniqueInput;
      create: ProvinceCreateInput;
      update: ProvinceUpdateInput;
    }
  ) => ProvincePromise;
  deleteProvince: (where: ProvinceWhereUniqueInput) => ProvincePromise;
  deleteManyProvinces: (where?: ProvinceWhereInput) => BatchPayloadPromise;
  createRegStatus: (data: RegStatusCreateInput) => RegStatusPromise;
  updateRegStatus: (
    args: { data: RegStatusUpdateInput; where: RegStatusWhereUniqueInput }
  ) => RegStatusPromise;
  upsertRegStatus: (
    args: {
      where: RegStatusWhereUniqueInput;
      create: RegStatusCreateInput;
      update: RegStatusUpdateInput;
    }
  ) => RegStatusPromise;
  deleteRegStatus: (where: RegStatusWhereUniqueInput) => RegStatusPromise;
  deleteManyRegStatuses: (where?: RegStatusWhereInput) => BatchPayloadPromise;
  createSchool: (data: SchoolCreateInput) => SchoolPromise;
  updateSchool: (
    args: { data: SchoolUpdateInput; where: SchoolWhereUniqueInput }
  ) => SchoolPromise;
  updateManySchools: (
    args: { data: SchoolUpdateManyMutationInput; where?: SchoolWhereInput }
  ) => BatchPayloadPromise;
  upsertSchool: (
    args: {
      where: SchoolWhereUniqueInput;
      create: SchoolCreateInput;
      update: SchoolUpdateInput;
    }
  ) => SchoolPromise;
  deleteSchool: (where: SchoolWhereUniqueInput) => SchoolPromise;
  deleteManySchools: (where?: SchoolWhereInput) => BatchPayloadPromise;
  createSchoolEdu: (data: SchoolEduCreateInput) => SchoolEduPromise;
  updateSchoolEdu: (
    args: { data: SchoolEduUpdateInput; where: SchoolEduWhereUniqueInput }
  ) => SchoolEduPromise;
  updateManySchoolEdus: (
    args: {
      data: SchoolEduUpdateManyMutationInput;
      where?: SchoolEduWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSchoolEdu: (
    args: {
      where: SchoolEduWhereUniqueInput;
      create: SchoolEduCreateInput;
      update: SchoolEduUpdateInput;
    }
  ) => SchoolEduPromise;
  deleteSchoolEdu: (where: SchoolEduWhereUniqueInput) => SchoolEduPromise;
  deleteManySchoolEdus: (where?: SchoolEduWhereInput) => BatchPayloadPromise;
  createStreet: (data: StreetCreateInput) => StreetPromise;
  updateStreet: (
    args: { data: StreetUpdateInput; where: StreetWhereUniqueInput }
  ) => StreetPromise;
  updateManyStreets: (
    args: { data: StreetUpdateManyMutationInput; where?: StreetWhereInput }
  ) => BatchPayloadPromise;
  upsertStreet: (
    args: {
      where: StreetWhereUniqueInput;
      create: StreetCreateInput;
      update: StreetUpdateInput;
    }
  ) => StreetPromise;
  deleteStreet: (where: StreetWhereUniqueInput) => StreetPromise;
  deleteManyStreets: (where?: StreetWhereInput) => BatchPayloadPromise;
  createUniversity: (data: UniversityCreateInput) => UniversityPromise;
  updateUniversity: (
    args: { data: UniversityUpdateInput; where: UniversityWhereUniqueInput }
  ) => UniversityPromise;
  updateManyUniversities: (
    args: {
      data: UniversityUpdateManyMutationInput;
      where?: UniversityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUniversity: (
    args: {
      where: UniversityWhereUniqueInput;
      create: UniversityCreateInput;
      update: UniversityUpdateInput;
    }
  ) => UniversityPromise;
  deleteUniversity: (where: UniversityWhereUniqueInput) => UniversityPromise;
  deleteManyUniversities: (where?: UniversityWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVillage: (data: VillageCreateInput) => VillagePromise;
  updateVillage: (
    args: { data: VillageUpdateInput; where: VillageWhereUniqueInput }
  ) => VillagePromise;
  updateManyVillages: (
    args: { data: VillageUpdateManyMutationInput; where?: VillageWhereInput }
  ) => BatchPayloadPromise;
  upsertVillage: (
    args: {
      where: VillageWhereUniqueInput;
      create: VillageCreateInput;
      update: VillageUpdateInput;
    }
  ) => VillagePromise;
  deleteVillage: (where: VillageWhereUniqueInput) => VillagePromise;
  deleteManyVillages: (where?: VillageWhereInput) => BatchPayloadPromise;
  createWork: (data: WorkCreateInput) => WorkPromise;
  updateWork: (
    args: { data: WorkUpdateInput; where: WorkWhereUniqueInput }
  ) => WorkPromise;
  updateManyWorks: (
    args: { data: WorkUpdateManyMutationInput; where?: WorkWhereInput }
  ) => BatchPayloadPromise;
  upsertWork: (
    args: {
      where: WorkWhereUniqueInput;
      create: WorkCreateInput;
      update: WorkUpdateInput;
    }
  ) => WorkPromise;
  deleteWork: (where: WorkWhereUniqueInput) => WorkPromise;
  deleteManyWorks: (where?: WorkWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  area: (
    where?: AreaSubscriptionWhereInput
  ) => AreaSubscriptionPayloadSubscription;
  city: (
    where?: CitySubscriptionWhereInput
  ) => CitySubscriptionPayloadSubscription;
  collegeEntranceExam: (
    where?: CollegeEntranceExamSubscriptionWhereInput
  ) => CollegeEntranceExamSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  family: (
    where?: FamilySubscriptionWhereInput
  ) => FamilySubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  major: (
    where?: MajorSubscriptionWhereInput
  ) => MajorSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  province: (
    where?: ProvinceSubscriptionWhereInput
  ) => ProvinceSubscriptionPayloadSubscription;
  regStatus: (
    where?: RegStatusSubscriptionWhereInput
  ) => RegStatusSubscriptionPayloadSubscription;
  school: (
    where?: SchoolSubscriptionWhereInput
  ) => SchoolSubscriptionPayloadSubscription;
  schoolEdu: (
    where?: SchoolEduSubscriptionWhereInput
  ) => SchoolEduSubscriptionPayloadSubscription;
  street: (
    where?: StreetSubscriptionWhereInput
  ) => StreetSubscriptionPayloadSubscription;
  university: (
    where?: UniversitySubscriptionWhereInput
  ) => UniversitySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  village: (
    where?: VillageSubscriptionWhereInput
  ) => VillageSubscriptionPayloadSubscription;
  work: (
    where?: WorkSubscriptionWhereInput
  ) => WorkSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Educationkind =
  | "PrimarySchool"
  | "JuniorMiddleSchool"
  | "HighSchool"
  | "VocationalHighSchool"
  | "TechnicalSchool"
  | "SecondarySpecializedSchool"
  | "JuniorCollege"
  | "Undergraduate"
  | "Master"
  | "Doctor"
  | "JuniorToCollege"
  | "HighToCollege"
  | "HighToJunior";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "birthdaycalendar_ASC"
  | "birthdaycalendar_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "uid_ASC"
  | "uid_DESC"
  | "token_ASC"
  | "token_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RegStatusOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AreaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StreetOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CollegeEntranceExamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subject_ASC"
  | "subject_DESC"
  | "culscore_ASC"
  | "culscore_DESC"
  | "proscore_ASC"
  | "proscore_DESC"
  | "candidatenum_ASC"
  | "candidatenum_DESC"
  | "times_ASC"
  | "times_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MajorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC"
  | "education_ASC"
  | "education_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FamilyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "relationship_ASC"
  | "relationship_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VillageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type SchoolOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "kind_ASC"
  | "kind_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "code_ASC"
  | "code_DESC"
  | "establishmentDate_ASC"
  | "establishmentDate_DESC"
  | "representative_ASC"
  | "representative_DESC"
  | "BusinessScope_ASC"
  | "BusinessScope_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WorkOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "department_ASC"
  | "department_DESC"
  | "post_ASC"
  | "post_DESC"
  | "jobContent_ASC"
  | "jobContent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UniversityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProvinceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "isPublished_ASC"
  | "isPublished_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC";

export type SchoolEduOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "grade_ASC"
  | "grade_DESC"
  | "className_ASC"
  | "className_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface CompanyCreateWithoutWorksInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationCreateOneWithoutCompaniesInput;
  BusinessScope?: String;
}

export type AreaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface VillageCreateOneInput {
  create?: VillageCreateInput;
  connect?: VillageWhereUniqueInput;
}

export interface CompanyUpsertWithWhereUniqueWithoutLocationInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutLocationDataInput;
  create: CompanyCreateWithoutLocationInput;
}

export interface VillageCreateInput {
  code: String;
  name: String;
  street: StreetCreateOneWithoutVillagesInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface StreetCreateOneWithoutVillagesInput {
  create?: StreetCreateWithoutVillagesInput;
  connect?: StreetWhereUniqueInput;
}

export interface VillageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VillageWhereInput;
  AND?: VillageSubscriptionWhereInput[] | VillageSubscriptionWhereInput;
  OR?: VillageSubscriptionWhereInput[] | VillageSubscriptionWhereInput;
  NOT?: VillageSubscriptionWhereInput[] | VillageSubscriptionWhereInput;
}

export interface StreetCreateWithoutVillagesInput {
  code: String;
  name: String;
  Area: AreaCreateOneWithoutTownsInput;
}

export type CollegeEntranceExamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolCreateManyWithoutLocationInput {
  create?:
    | SchoolCreateWithoutLocationInput[]
    | SchoolCreateWithoutLocationInput;
  connect?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
}

export interface StreetSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StreetWhereInput;
  AND?: StreetSubscriptionWhereInput[] | StreetSubscriptionWhereInput;
  OR?: StreetSubscriptionWhereInput[] | StreetSubscriptionWhereInput;
  NOT?: StreetSubscriptionWhereInput[] | StreetSubscriptionWhereInput;
}

export interface SchoolCreateWithoutLocationInput {
  name?: String;
  kind?: Educationkind;
}

export interface SchoolSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolWhereInput;
  AND?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
  OR?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
  NOT?: SchoolSubscriptionWhereInput[] | SchoolSubscriptionWhereInput;
}

export interface CompanyCreateManyWithoutLocationInput {
  create?:
    | CompanyCreateWithoutLocationInput[]
    | CompanyCreateWithoutLocationInput;
  connect?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
}

export interface SchoolWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  kind?: Educationkind;
  kind_not?: Educationkind;
  kind_in?: Educationkind[] | Educationkind;
  kind_not_in?: Educationkind[] | Educationkind;
  location?: LocationWhereInput;
  AND?: SchoolWhereInput[] | SchoolWhereInput;
  OR?: SchoolWhereInput[] | SchoolWhereInput;
  NOT?: SchoolWhereInput[] | SchoolWhereInput;
}

export interface CompanyCreateWithoutLocationInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  BusinessScope?: String;
  works?: WorkCreateManyWithoutCompanyInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  province?: ProvinceWhereInput;
  city?: CityWhereInput;
  area?: AreaWhereInput;
  street?: StreetWhereInput;
  village?: VillageWhereInput;
  schools_every?: SchoolWhereInput;
  schools_some?: SchoolWhereInput;
  schools_none?: SchoolWhereInput;
  companies_every?: CompanyWhereInput;
  companies_some?: CompanyWhereInput;
  companies_none?: CompanyWhereInput;
  universities_every?: UniversityWhereInput;
  universities_some?: UniversityWhereInput;
  universities_none?: UniversityWhereInput;
  people_every?: UserWhereInput;
  people_some?: UserWhereInput;
  people_none?: UserWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface WorkCreateManyWithoutCompanyInput {
  create?: WorkCreateWithoutCompanyInput[] | WorkCreateWithoutCompanyInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
}

export interface WorkWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  endTime?: DateTimeInput;
  endTime_not?: DateTimeInput;
  endTime_in?: DateTimeInput[] | DateTimeInput;
  endTime_not_in?: DateTimeInput[] | DateTimeInput;
  endTime_lt?: DateTimeInput;
  endTime_lte?: DateTimeInput;
  endTime_gt?: DateTimeInput;
  endTime_gte?: DateTimeInput;
  company?: CompanyWhereInput;
  department?: String;
  department_not?: String;
  department_in?: String[] | String;
  department_not_in?: String[] | String;
  department_lt?: String;
  department_lte?: String;
  department_gt?: String;
  department_gte?: String;
  department_contains?: String;
  department_not_contains?: String;
  department_starts_with?: String;
  department_not_starts_with?: String;
  department_ends_with?: String;
  department_not_ends_with?: String;
  post?: String;
  post_not?: String;
  post_in?: String[] | String;
  post_not_in?: String[] | String;
  post_lt?: String;
  post_lte?: String;
  post_gt?: String;
  post_gte?: String;
  post_contains?: String;
  post_not_contains?: String;
  post_starts_with?: String;
  post_not_starts_with?: String;
  post_ends_with?: String;
  post_not_ends_with?: String;
  jobContent?: String;
  jobContent_not?: String;
  jobContent_in?: String[] | String;
  jobContent_not_in?: String[] | String;
  jobContent_lt?: String;
  jobContent_lte?: String;
  jobContent_gt?: String;
  jobContent_gte?: String;
  jobContent_contains?: String;
  jobContent_not_contains?: String;
  jobContent_starts_with?: String;
  jobContent_not_starts_with?: String;
  jobContent_ends_with?: String;
  jobContent_not_ends_with?: String;
  worker?: UserWhereInput;
  AND?: WorkWhereInput[] | WorkWhereInput;
  OR?: WorkWhereInput[] | WorkWhereInput;
  NOT?: WorkWhereInput[] | WorkWhereInput;
}

export interface WorkCreateWithoutCompanyInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  department?: String;
  post?: String;
  jobContent?: String;
  worker?: UserCreateOneWithoutWorksInput;
}

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  isPublished?: Boolean;
  isPublished_not?: Boolean;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  author?: UserWhereInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface UserCreateOneWithoutWorksInput {
  create?: UserCreateWithoutWorksInput;
  connect?: UserWhereUniqueInput;
}

export interface UniversityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  location?: LocationWhereInput;
  major_every?: MajorWhereInput;
  major_some?: MajorWhereInput;
  major_none?: MajorWhereInput;
  AND?: UniversityWhereInput[] | UniversityWhereInput;
  OR?: UniversityWhereInput[] | UniversityWhereInput;
  NOT?: UniversityWhereInput[] | UniversityWhereInput;
}

export interface UserCreateWithoutWorksInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutPeopleInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
}

export interface FamilyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  from?: UserWhereInput;
  to?: PersonWhereInput;
  relationship?: String;
  relationship_not?: String;
  relationship_in?: String[] | String;
  relationship_not_in?: String[] | String;
  relationship_lt?: String;
  relationship_lte?: String;
  relationship_gt?: String;
  relationship_gte?: String;
  relationship_contains?: String;
  relationship_not_contains?: String;
  relationship_starts_with?: String;
  relationship_not_starts_with?: String;
  relationship_ends_with?: String;
  relationship_not_ends_with?: String;
  spouse?: FamilyWhereInput;
  status?: String;
  status_not?: String;
  status_in?: String[] | String;
  status_not_in?: String[] | String;
  status_lt?: String;
  status_lte?: String;
  status_gt?: String;
  status_gte?: String;
  status_contains?: String;
  status_not_contains?: String;
  status_starts_with?: String;
  status_not_starts_with?: String;
  status_ends_with?: String;
  status_not_ends_with?: String;
  AND?: FamilyWhereInput[] | FamilyWhereInput;
  OR?: FamilyWhereInput[] | FamilyWhereInput;
  NOT?: FamilyWhereInput[] | FamilyWhereInput;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface SchoolEduWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  school?: SchoolWhereInput;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  major?: MajorWhereInput;
  grade?: Int;
  grade_not?: Int;
  grade_in?: Int[] | Int;
  grade_not_in?: Int[] | Int;
  grade_lt?: Int;
  grade_lte?: Int;
  grade_gt?: Int;
  grade_gte?: Int;
  className?: String;
  className_not?: String;
  className_in?: String[] | String;
  className_not_in?: String[] | String;
  className_lt?: String;
  className_lte?: String;
  className_gt?: String;
  className_gte?: String;
  className_contains?: String;
  className_not_contains?: String;
  className_starts_with?: String;
  className_not_starts_with?: String;
  className_ends_with?: String;
  className_not_ends_with?: String;
  students_every?: UserWhereInput;
  students_some?: UserWhereInput;
  students_none?: UserWhereInput;
  AND?: SchoolEduWhereInput[] | SchoolEduWhereInput;
  OR?: SchoolEduWhereInput[] | SchoolEduWhereInput;
  NOT?: SchoolEduWhereInput[] | SchoolEduWhereInput;
}

export interface PostCreateWithoutAuthorInput {
  isPublished?: Boolean;
  title: String;
  content: String;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PersonWhereInput;
  AND?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  OR?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  NOT?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
}

export interface RegStatusCreateOneWithoutApplicantsInput {
  create?: RegStatusCreateWithoutApplicantsInput;
  connect?: RegStatusWhereUniqueInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface RegStatusCreateWithoutApplicantsInput {
  university?: UniversityCreateOneInput;
  major: MajorCreateOneInput;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface UniversityCreateOneInput {
  create?: UniversityCreateInput;
  connect?: UniversityWhereUniqueInput;
}

export interface CitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CityWhereInput;
  AND?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  OR?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
  NOT?: CitySubscriptionWhereInput[] | CitySubscriptionWhereInput;
}

export interface UniversityCreateInput {
  name: String;
  location?: LocationCreateOneWithoutUniversitiesInput;
  major?: MajorCreateManyWithoutUniversitiesInput;
}

export interface WorkUpdateManyMutationInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  department?: String;
  post?: String;
  jobContent?: String;
}

export interface LocationCreateOneWithoutUniversitiesInput {
  create?: LocationCreateWithoutUniversitiesInput;
  connect?: LocationWhereUniqueInput;
}

export interface VillageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  street?: StreetWhereInput;
  AND?: VillageWhereInput[] | VillageWhereInput;
  OR?: VillageWhereInput[] | VillageWhereInput;
  NOT?: VillageWhereInput[] | VillageWhereInput;
}

export interface LocationCreateWithoutUniversitiesInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  people?: UserCreateManyWithoutBirthplaceInput;
}

export interface VillageUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface UserCreateManyWithoutBirthplaceInput {
  create?:
    | UserCreateWithoutBirthplaceInput[]
    | UserCreateWithoutBirthplaceInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface VillageUpdateInput {
  code?: String;
  name?: String;
  street?: StreetUpdateOneRequiredWithoutVillagesInput;
}

export interface UserCreateWithoutBirthplaceInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
}

export interface AreaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  city?: CityWhereInput;
  towns_every?: StreetWhereInput;
  towns_some?: StreetWhereInput;
  towns_none?: StreetWhereInput;
  AND?: AreaWhereInput[] | AreaWhereInput;
  OR?: AreaWhereInput[] | AreaWhereInput;
  NOT?: AreaWhereInput[] | AreaWhereInput;
}

export interface FamilyCreateManyWithoutFromInput {
  create?: FamilyCreateWithoutFromInput[] | FamilyCreateWithoutFromInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
}

export interface CollegeEntranceExamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  province?: ProvinceWhereInput;
  subject?: String;
  subject_not?: String;
  subject_in?: String[] | String;
  subject_not_in?: String[] | String;
  subject_lt?: String;
  subject_lte?: String;
  subject_gt?: String;
  subject_gte?: String;
  subject_contains?: String;
  subject_not_contains?: String;
  subject_starts_with?: String;
  subject_not_starts_with?: String;
  subject_ends_with?: String;
  subject_not_ends_with?: String;
  culscore?: Float;
  culscore_not?: Float;
  culscore_in?: Float[] | Float;
  culscore_not_in?: Float[] | Float;
  culscore_lt?: Float;
  culscore_lte?: Float;
  culscore_gt?: Float;
  culscore_gte?: Float;
  proscore?: Float;
  proscore_not?: Float;
  proscore_in?: Float[] | Float;
  proscore_not_in?: Float[] | Float;
  proscore_lt?: Float;
  proscore_lte?: Float;
  proscore_gt?: Float;
  proscore_gte?: Float;
  candidatenum?: String;
  candidatenum_not?: String;
  candidatenum_in?: String[] | String;
  candidatenum_not_in?: String[] | String;
  candidatenum_lt?: String;
  candidatenum_lte?: String;
  candidatenum_gt?: String;
  candidatenum_gte?: String;
  candidatenum_contains?: String;
  candidatenum_not_contains?: String;
  candidatenum_starts_with?: String;
  candidatenum_not_starts_with?: String;
  candidatenum_ends_with?: String;
  candidatenum_not_ends_with?: String;
  times?: Int;
  times_not?: Int;
  times_in?: Int[] | Int;
  times_not_in?: Int[] | Int;
  times_lt?: Int;
  times_lte?: Int;
  times_gt?: Int;
  times_gte?: Int;
  student?: UserWhereInput;
  AND?: CollegeEntranceExamWhereInput[] | CollegeEntranceExamWhereInput;
  OR?: CollegeEntranceExamWhereInput[] | CollegeEntranceExamWhereInput;
  NOT?: CollegeEntranceExamWhereInput[] | CollegeEntranceExamWhereInput;
}

export interface FamilyCreateWithoutFromInput {
  to: PersonCreateOneWithoutFamiliesInput;
  relationship: String;
  spouse?: FamilyCreateOneInput;
  status: String;
}

export interface UniversityUpdateManyMutationInput {
  name?: String;
}

export interface PersonCreateOneWithoutFamiliesInput {
  create?: PersonCreateWithoutFamiliesInput;
  connect?: PersonWhereUniqueInput;
}

export interface StreetUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface PersonCreateWithoutFamiliesInput {
  name: String;
  user?: UserCreateOneInput;
}

export interface StreetUpdateInput {
  code?: String;
  name?: String;
  Area?: AreaUpdateOneRequiredWithoutTownsInput;
  villages?: VillageUpdateManyWithoutStreetInput;
}

export interface FamilyCreateOneInput {
  create?: FamilyCreateInput;
  connect?: FamilyWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutStudiesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutStudiesDataInput;
  create: UserCreateWithoutStudiesInput;
}

export interface FamilyCreateInput {
  from: UserCreateOneWithoutFamiliesInput;
  to: PersonCreateOneWithoutFamiliesInput;
  relationship: String;
  spouse?: FamilyCreateOneInput;
  status: String;
}

export interface UserUpdateWithoutStudiesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutPeopleInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  families?: FamilyUpdateManyWithoutFromInput;
  works?: WorkUpdateManyWithoutWorkerInput;
}

export interface UserCreateOneWithoutFamiliesInput {
  create?: UserCreateWithoutFamiliesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateManyWithoutStudiesInput {
  create?: UserCreateWithoutStudiesInput[] | UserCreateWithoutStudiesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutStudiesInput[]
    | UserUpdateWithWhereUniqueWithoutStudiesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutStudiesInput[]
    | UserUpsertWithWhereUniqueWithoutStudiesInput;
}

export interface UserCreateWithoutFamiliesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutPeopleInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
}

export interface CityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  province?: ProvinceWhereInput;
  areas_every?: AreaWhereInput;
  areas_some?: AreaWhereInput;
  areas_none?: AreaWhereInput;
  AND?: CityWhereInput[] | CityWhereInput;
  OR?: CityWhereInput[] | CityWhereInput;
  NOT?: CityWhereInput[] | CityWhereInput;
}

export interface SchoolEduCreateManyWithoutStudentsInput {
  create?:
    | SchoolEduCreateWithoutStudentsInput[]
    | SchoolEduCreateWithoutStudentsInput;
  connect?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
}

export interface UserCreateWithoutStudiesInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutPeopleInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  families?: FamilyCreateManyWithoutFromInput;
  works?: WorkCreateManyWithoutWorkerInput;
}

export interface SchoolEduCreateWithoutStudentsInput {
  school?: SchoolCreateOneInput;
  startTime?: DateTimeInput;
  major?: MajorCreateOneInput;
  grade?: Int;
  className?: String;
}

export type MajorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SchoolCreateOneInput {
  create?: SchoolCreateInput;
  connect?: SchoolWhereUniqueInput;
}

export interface SchoolUpdateManyMutationInput {
  name?: String;
  kind?: Educationkind;
}

export interface SchoolCreateInput {
  name?: String;
  kind?: Educationkind;
  location?: LocationCreateOneWithoutSchoolsInput;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LocationCreateOneWithoutSchoolsInput {
  create?: LocationCreateWithoutSchoolsInput;
  connect?: LocationWhereUniqueInput;
}

export interface UserUpdateWithoutRegStatusDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutPeopleInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
}

export interface LocationCreateWithoutSchoolsInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyWithoutLocationInput;
  people?: UserCreateManyWithoutBirthplaceInput;
}

export interface UserUpdateManyWithoutRegStatusInput {
  create?: UserCreateWithoutRegStatusInput[] | UserCreateWithoutRegStatusInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutRegStatusInput[]
    | UserUpdateWithWhereUniqueWithoutRegStatusInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutRegStatusInput[]
    | UserUpsertWithWhereUniqueWithoutRegStatusInput;
}

export interface UniversityCreateManyWithoutLocationInput {
  create?:
    | UniversityCreateWithoutLocationInput[]
    | UniversityCreateWithoutLocationInput;
  connect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
}

export interface RegStatusUpdateInput {
  university?: UniversityUpdateOneInput;
  major?: MajorUpdateOneRequiredInput;
  applicants?: UserUpdateManyWithoutRegStatusInput;
}

export interface UniversityCreateWithoutLocationInput {
  name: String;
  major?: MajorCreateManyWithoutUniversitiesInput;
}

export interface UserCreateManyWithoutRegStatusInput {
  create?: UserCreateWithoutRegStatusInput[] | UserCreateWithoutRegStatusInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface MajorCreateManyWithoutUniversitiesInput {
  create?:
    | MajorCreateWithoutUniversitiesInput[]
    | MajorCreateWithoutUniversitiesInput;
  connect?: MajorWhereUniqueInput[] | MajorWhereUniqueInput;
}

export interface RegStatusCreateInput {
  university?: UniversityCreateOneInput;
  major: MajorCreateOneInput;
  applicants?: UserCreateManyWithoutRegStatusInput;
}

export interface MajorCreateWithoutUniversitiesInput {
  name: String;
  category: String;
  education: Educationkind;
}

export interface ProvinceUpdateInput {
  code?: String;
  name?: String;
  cities?: CityUpdateManyWithoutProvinceInput;
}

export interface MajorCreateOneInput {
  create?: MajorCreateInput;
  connect?: MajorWhereUniqueInput;
}

export type RegStatusWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MajorCreateInput {
  name: String;
  category: String;
  education: Educationkind;
  universities?: UniversityCreateManyWithoutMajorInput;
}

export interface UserUpdateWithoutPostsDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutPeopleInput;
  uid?: String;
  token?: String;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
}

export interface UniversityCreateManyWithoutMajorInput {
  create?:
    | UniversityCreateWithoutMajorInput[]
    | UniversityCreateWithoutMajorInput;
  connect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
}

export interface PostUpdateInput {
  isPublished?: Boolean;
  title?: String;
  content?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
}

export interface UniversityCreateWithoutMajorInput {
  name: String;
  location?: LocationCreateOneWithoutUniversitiesInput;
}

export interface UserCreateWithoutPostsInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutPeopleInput;
  uid: String;
  token: String;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
}

export interface WorkCreateManyWithoutWorkerInput {
  create?: WorkCreateWithoutWorkerInput[] | WorkCreateWithoutWorkerInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
}

export interface PostCreateInput {
  isPublished?: Boolean;
  title: String;
  content: String;
  author: UserCreateOneWithoutPostsInput;
}

export interface WorkCreateWithoutWorkerInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyCreateOneWithoutWorksInput;
  department?: String;
  post?: String;
  jobContent?: String;
}

export interface PersonUpdateManyMutationInput {
  name?: String;
}

export interface CompanyCreateOneWithoutWorksInput {
  create?: CompanyCreateWithoutWorksInput;
  connect?: CompanyWhereUniqueInput;
}

export interface FamilyUpdateWithoutToDataInput {
  from?: UserUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export interface LocationUpsertWithoutPeopleInput {
  update: LocationUpdateWithoutPeopleDataInput;
  create: LocationCreateWithoutPeopleInput;
}

export interface FamilyUpdateWithWhereUniqueWithoutToInput {
  where: FamilyWhereUniqueInput;
  data: FamilyUpdateWithoutToDataInput;
}

export interface LocationCreateOneWithoutCompaniesInput {
  create?: LocationCreateWithoutCompaniesInput;
  connect?: LocationWhereUniqueInput;
}

export interface PersonUpdateInput {
  name?: String;
  user?: UserUpdateOneInput;
  families?: FamilyUpdateManyWithoutToInput;
}

export interface LocationCreateWithoutCompaniesInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyWithoutLocationInput;
  people?: UserCreateManyWithoutBirthplaceInput;
}

export interface FamilyCreateWithoutToInput {
  from: UserCreateOneWithoutFamiliesInput;
  relationship: String;
  spouse?: FamilyCreateOneInput;
  status: String;
}

export interface CollegeEntranceExamUpdateInput {
  province?: ProvinceUpdateOneRequiredInput;
  subject?: String;
  culscore?: Float;
  proscore?: Float;
  candidatenum?: String;
  times?: Int;
  student?: UserUpdateOneRequiredInput;
}

export interface PersonCreateInput {
  name: String;
  user?: UserCreateOneInput;
  families?: FamilyCreateManyWithoutToInput;
}

export interface ProvinceUpdateOneRequiredInput {
  create?: ProvinceCreateInput;
  update?: ProvinceUpdateDataInput;
  upsert?: ProvinceUpsertNestedInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface MajorUpdateManyMutationInput {
  name?: String;
  category?: String;
  education?: Educationkind;
}

export interface ProvinceUpdateDataInput {
  code?: String;
  name?: String;
  cities?: CityUpdateManyWithoutProvinceInput;
}

export interface LocationUpdateManyMutationInput {
  name?: String;
}

export interface CityUpdateManyWithoutProvinceInput {
  create?: CityCreateWithoutProvinceInput[] | CityCreateWithoutProvinceInput;
  delete?: CityWhereUniqueInput[] | CityWhereUniqueInput;
  connect?: CityWhereUniqueInput[] | CityWhereUniqueInput;
  disconnect?: CityWhereUniqueInput[] | CityWhereUniqueInput;
  update?:
    | CityUpdateWithWhereUniqueWithoutProvinceInput[]
    | CityUpdateWithWhereUniqueWithoutProvinceInput;
  upsert?:
    | CityUpsertWithWhereUniqueWithoutProvinceInput[]
    | CityUpsertWithWhereUniqueWithoutProvinceInput;
}

export interface LocationUpdateInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyWithoutLocationInput;
  people?: UserUpdateManyWithoutBirthplaceInput;
}

export interface CityUpdateWithWhereUniqueWithoutProvinceInput {
  where: CityWhereUniqueInput;
  data: CityUpdateWithoutProvinceDataInput;
}

export interface FamilyUpdateManyMutationInput {
  relationship?: String;
  status?: String;
}

export interface CityUpdateWithoutProvinceDataInput {
  code?: String;
  name?: String;
  areas?: AreaUpdateManyWithoutCityInput;
}

export interface FamilyUpdateInput {
  from?: UserUpdateOneRequiredWithoutFamiliesInput;
  to?: PersonUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export interface CityUpsertWithWhereUniqueWithoutProvinceInput {
  where: CityWhereUniqueInput;
  update: CityUpdateWithoutProvinceDataInput;
  create: CityCreateWithoutProvinceInput;
}

export interface CompanyUpdateInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationUpdateOneWithoutCompaniesInput;
  BusinessScope?: String;
  works?: WorkUpdateManyWithoutCompanyInput;
}

export interface ProvinceUpsertNestedInput {
  update: ProvinceUpdateDataInput;
  create: ProvinceCreateInput;
}

export interface AreaCreateInput {
  code: String;
  name: String;
  city: CityCreateOneWithoutAreasInput;
  towns?: StreetCreateManyWithoutAreaInput;
}

export type CityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface CityCreateWithoutAreasInput {
  code: String;
  name: String;
  province: ProvinceCreateOneWithoutCitiesInput;
}

export interface UserUpdateDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutPeopleInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
}

export interface ProvinceCreateWithoutCitiesInput {
  code: String;
  name: String;
}

export interface LocationUpdateOneWithoutPeopleInput {
  create?: LocationCreateWithoutPeopleInput;
  update?: LocationUpdateWithoutPeopleDataInput;
  upsert?: LocationUpsertWithoutPeopleInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface StreetCreateWithoutAreaInput {
  code: String;
  name: String;
  villages?: VillageCreateManyWithoutStreetInput;
}

export interface LocationUpdateWithoutPeopleDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyWithoutLocationInput;
}

export interface VillageCreateWithoutStreetInput {
  code: String;
  name: String;
}

export interface ProvinceUpdateOneInput {
  create?: ProvinceCreateInput;
  update?: ProvinceUpdateDataInput;
  upsert?: ProvinceUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProvinceWhereUniqueInput;
}

export interface CityUpdateOneRequiredWithoutAreasInput {
  create?: CityCreateWithoutAreasInput;
  update?: CityUpdateWithoutAreasDataInput;
  upsert?: CityUpsertWithoutAreasInput;
  connect?: CityWhereUniqueInput;
}

export interface CityUpdateOneInput {
  create?: CityCreateInput;
  update?: CityUpdateDataInput;
  upsert?: CityUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CityWhereUniqueInput;
}

export interface ProvinceUpdateOneRequiredWithoutCitiesInput {
  create?: ProvinceCreateWithoutCitiesInput;
  update?: ProvinceUpdateWithoutCitiesDataInput;
  upsert?: ProvinceUpsertWithoutCitiesInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface CityUpdateDataInput {
  code?: String;
  name?: String;
  province?: ProvinceUpdateOneRequiredWithoutCitiesInput;
  areas?: AreaUpdateManyWithoutCityInput;
}

export interface ProvinceUpsertWithoutCitiesInput {
  update: ProvinceUpdateWithoutCitiesDataInput;
  create: ProvinceCreateWithoutCitiesInput;
}

export interface CityUpsertNestedInput {
  update: CityUpdateDataInput;
  create: CityCreateInput;
}

export interface StreetUpdateManyWithoutAreaInput {
  create?: StreetCreateWithoutAreaInput[] | StreetCreateWithoutAreaInput;
  delete?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
  connect?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
  disconnect?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
  update?:
    | StreetUpdateWithWhereUniqueWithoutAreaInput[]
    | StreetUpdateWithWhereUniqueWithoutAreaInput;
  upsert?:
    | StreetUpsertWithWhereUniqueWithoutAreaInput[]
    | StreetUpsertWithWhereUniqueWithoutAreaInput;
}

export interface AreaUpdateOneInput {
  create?: AreaCreateInput;
  update?: AreaUpdateDataInput;
  upsert?: AreaUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AreaWhereUniqueInput;
}

export interface StreetUpdateWithoutAreaDataInput {
  code?: String;
  name?: String;
  villages?: VillageUpdateManyWithoutStreetInput;
}

export interface AreaUpdateDataInput {
  code?: String;
  name?: String;
  city?: CityUpdateOneRequiredWithoutAreasInput;
  towns?: StreetUpdateManyWithoutAreaInput;
}

export interface VillageUpdateWithWhereUniqueWithoutStreetInput {
  where: VillageWhereUniqueInput;
  data: VillageUpdateWithoutStreetDataInput;
}

export interface AreaUpsertNestedInput {
  update: AreaUpdateDataInput;
  create: AreaCreateInput;
}

export interface VillageUpsertWithWhereUniqueWithoutStreetInput {
  where: VillageWhereUniqueInput;
  update: VillageUpdateWithoutStreetDataInput;
  create: VillageCreateWithoutStreetInput;
}

export interface StreetUpdateOneInput {
  create?: StreetCreateInput;
  update?: StreetUpdateDataInput;
  upsert?: StreetUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StreetWhereUniqueInput;
}

export interface AreaUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface StreetUpdateDataInput {
  code?: String;
  name?: String;
  Area?: AreaUpdateOneRequiredWithoutTownsInput;
  villages?: VillageUpdateManyWithoutStreetInput;
}

export interface CollegeEntranceExamUpdateManyMutationInput {
  subject?: String;
  culscore?: Float;
  proscore?: Float;
  candidatenum?: String;
  times?: Int;
}

export interface AreaUpdateOneRequiredWithoutTownsInput {
  create?: AreaCreateWithoutTownsInput;
  update?: AreaUpdateWithoutTownsDataInput;
  upsert?: AreaUpsertWithoutTownsInput;
  connect?: AreaWhereUniqueInput;
}

export interface AreaCreateManyWithoutCityInput {
  create?: AreaCreateWithoutCityInput[] | AreaCreateWithoutCityInput;
  connect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
}

export interface AreaUpdateWithoutTownsDataInput {
  code?: String;
  name?: String;
  city?: CityUpdateOneRequiredWithoutAreasInput;
}

export interface CityUpdateInput {
  code?: String;
  name?: String;
  province?: ProvinceUpdateOneRequiredWithoutCitiesInput;
  areas?: AreaUpdateManyWithoutCityInput;
}

export interface AreaUpsertWithoutTownsInput {
  update: AreaUpdateWithoutTownsDataInput;
  create: AreaCreateWithoutTownsInput;
}

export interface AreaUpdateWithWhereUniqueWithoutCityInput {
  where: AreaWhereUniqueInput;
  data: AreaUpdateWithoutCityDataInput;
}

export interface StreetUpsertNestedInput {
  update: StreetUpdateDataInput;
  create: StreetCreateInput;
}

export interface AreaUpsertWithWhereUniqueWithoutCityInput {
  where: AreaWhereUniqueInput;
  update: AreaUpdateWithoutCityDataInput;
  create: AreaCreateWithoutCityInput;
}

export interface VillageUpdateOneInput {
  create?: VillageCreateInput;
  update?: VillageUpdateDataInput;
  upsert?: VillageUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VillageWhereUniqueInput;
}

export interface CollegeEntranceExamCreateInput {
  province: ProvinceCreateOneInput;
  subject: String;
  culscore: Float;
  proscore?: Float;
  candidatenum: String;
  times?: Int;
  student: UserCreateOneInput;
}

export interface VillageUpdateDataInput {
  code?: String;
  name?: String;
  street?: StreetUpdateOneRequiredWithoutVillagesInput;
}

export interface ProvinceCreateInput {
  code: String;
  name: String;
  cities?: CityCreateManyWithoutProvinceInput;
}

export interface StreetUpdateOneRequiredWithoutVillagesInput {
  create?: StreetCreateWithoutVillagesInput;
  update?: StreetUpdateWithoutVillagesDataInput;
  upsert?: StreetUpsertWithoutVillagesInput;
  connect?: StreetWhereUniqueInput;
}

export interface CityCreateWithoutProvinceInput {
  code: String;
  name: String;
  areas?: AreaCreateManyWithoutCityInput;
}

export interface StreetUpdateWithoutVillagesDataInput {
  code?: String;
  name?: String;
  Area?: AreaUpdateOneRequiredWithoutTownsInput;
}

export interface UserCreateInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutPeopleInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  regStatus?: RegStatusCreateOneWithoutApplicantsInput;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
}

export interface StreetUpsertWithoutVillagesInput {
  update: StreetUpdateWithoutVillagesDataInput;
  create: StreetCreateWithoutVillagesInput;
}

export interface LocationCreateWithoutPeopleInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyWithoutLocationInput;
}

export interface VillageUpsertNestedInput {
  update: VillageUpdateDataInput;
  create: VillageCreateInput;
}

export interface AreaCreateOneInput {
  create?: AreaCreateInput;
  connect?: AreaWhereUniqueInput;
}

export interface SchoolUpdateManyWithoutLocationInput {
  create?:
    | SchoolCreateWithoutLocationInput[]
    | SchoolCreateWithoutLocationInput;
  delete?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
  connect?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
  disconnect?: SchoolWhereUniqueInput[] | SchoolWhereUniqueInput;
  update?:
    | SchoolUpdateWithWhereUniqueWithoutLocationInput[]
    | SchoolUpdateWithWhereUniqueWithoutLocationInput;
  upsert?:
    | SchoolUpsertWithWhereUniqueWithoutLocationInput[]
    | SchoolUpsertWithWhereUniqueWithoutLocationInput;
}

export interface StreetCreateInput {
  code: String;
  name: String;
  Area: AreaCreateOneWithoutTownsInput;
  villages?: VillageCreateManyWithoutStreetInput;
}

export interface SchoolUpdateWithWhereUniqueWithoutLocationInput {
  where: SchoolWhereUniqueInput;
  data: SchoolUpdateWithoutLocationDataInput;
}

export interface AreaCreateWithoutTownsInput {
  code: String;
  name: String;
  city: CityCreateOneWithoutAreasInput;
}

export interface SchoolUpdateWithoutLocationDataInput {
  name?: String;
  kind?: Educationkind;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface SchoolUpsertWithWhereUniqueWithoutLocationInput {
  where: SchoolWhereUniqueInput;
  update: SchoolUpdateWithoutLocationDataInput;
  create: SchoolCreateWithoutLocationInput;
}

export interface SchoolEduSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SchoolEduWhereInput;
  AND?: SchoolEduSubscriptionWhereInput[] | SchoolEduSubscriptionWhereInput;
  OR?: SchoolEduSubscriptionWhereInput[] | SchoolEduSubscriptionWhereInput;
  NOT?: SchoolEduSubscriptionWhereInput[] | SchoolEduSubscriptionWhereInput;
}

export interface CompanyUpdateManyWithoutLocationInput {
  create?:
    | CompanyCreateWithoutLocationInput[]
    | CompanyCreateWithoutLocationInput;
  delete?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
  connect?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
  disconnect?: CompanyWhereUniqueInput[] | CompanyWhereUniqueInput;
  update?:
    | CompanyUpdateWithWhereUniqueWithoutLocationInput[]
    | CompanyUpdateWithWhereUniqueWithoutLocationInput;
  upsert?:
    | CompanyUpsertWithWhereUniqueWithoutLocationInput[]
    | CompanyUpsertWithWhereUniqueWithoutLocationInput;
}

export interface ProvinceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProvinceWhereInput;
  AND?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
  OR?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
  NOT?: ProvinceSubscriptionWhereInput[] | ProvinceSubscriptionWhereInput;
}

export interface CompanyUpdateWithWhereUniqueWithoutLocationInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutLocationDataInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  gender?: String;
  gender_not?: String;
  gender_in?: String[] | String;
  gender_not_in?: String[] | String;
  gender_lt?: String;
  gender_lte?: String;
  gender_gt?: String;
  gender_gte?: String;
  gender_contains?: String;
  gender_not_contains?: String;
  gender_starts_with?: String;
  gender_not_starts_with?: String;
  gender_ends_with?: String;
  gender_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  birthdaycalendar?: String;
  birthdaycalendar_not?: String;
  birthdaycalendar_in?: String[] | String;
  birthdaycalendar_not_in?: String[] | String;
  birthdaycalendar_lt?: String;
  birthdaycalendar_lte?: String;
  birthdaycalendar_gt?: String;
  birthdaycalendar_gte?: String;
  birthdaycalendar_contains?: String;
  birthdaycalendar_not_contains?: String;
  birthdaycalendar_starts_with?: String;
  birthdaycalendar_not_starts_with?: String;
  birthdaycalendar_ends_with?: String;
  birthdaycalendar_not_ends_with?: String;
  birthday?: DateTimeInput;
  birthday_not?: DateTimeInput;
  birthday_in?: DateTimeInput[] | DateTimeInput;
  birthday_not_in?: DateTimeInput[] | DateTimeInput;
  birthday_lt?: DateTimeInput;
  birthday_lte?: DateTimeInput;
  birthday_gt?: DateTimeInput;
  birthday_gte?: DateTimeInput;
  birthplace?: LocationWhereInput;
  uid?: String;
  uid_not?: String;
  uid_in?: String[] | String;
  uid_not_in?: String[] | String;
  uid_lt?: String;
  uid_lte?: String;
  uid_gt?: String;
  uid_gte?: String;
  uid_contains?: String;
  uid_not_contains?: String;
  uid_starts_with?: String;
  uid_not_starts_with?: String;
  uid_ends_with?: String;
  uid_not_ends_with?: String;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  regStatus?: RegStatusWhereInput;
  families_every?: FamilyWhereInput;
  families_some?: FamilyWhereInput;
  families_none?: FamilyWhereInput;
  studies_every?: SchoolEduWhereInput;
  studies_some?: SchoolEduWhereInput;
  studies_none?: SchoolEduWhereInput;
  works_every?: WorkWhereInput;
  works_some?: WorkWhereInput;
  works_none?: WorkWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CompanyUpdateWithoutLocationDataInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  BusinessScope?: String;
  works?: WorkUpdateManyWithoutCompanyInput;
}

export interface MajorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  category?: String;
  category_not?: String;
  category_in?: String[] | String;
  category_not_in?: String[] | String;
  category_lt?: String;
  category_lte?: String;
  category_gt?: String;
  category_gte?: String;
  category_contains?: String;
  category_not_contains?: String;
  category_starts_with?: String;
  category_not_starts_with?: String;
  category_ends_with?: String;
  category_not_ends_with?: String;
  education?: Educationkind;
  education_not?: Educationkind;
  education_in?: Educationkind[] | Educationkind;
  education_not_in?: Educationkind[] | Educationkind;
  universities_every?: UniversityWhereInput;
  universities_some?: UniversityWhereInput;
  universities_none?: UniversityWhereInput;
  AND?: MajorWhereInput[] | MajorWhereInput;
  OR?: MajorWhereInput[] | MajorWhereInput;
  NOT?: MajorWhereInput[] | MajorWhereInput;
}

export interface WorkUpdateManyWithoutCompanyInput {
  create?: WorkCreateWithoutCompanyInput[] | WorkCreateWithoutCompanyInput;
  delete?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  disconnect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  update?:
    | WorkUpdateWithWhereUniqueWithoutCompanyInput[]
    | WorkUpdateWithWhereUniqueWithoutCompanyInput;
  upsert?:
    | WorkUpsertWithWhereUniqueWithoutCompanyInput[]
    | WorkUpsertWithWhereUniqueWithoutCompanyInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface WorkUpdateWithWhereUniqueWithoutCompanyInput {
  where: WorkWhereUniqueInput;
  data: WorkUpdateWithoutCompanyDataInput;
}

export interface FamilySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FamilyWhereInput;
  AND?: FamilySubscriptionWhereInput[] | FamilySubscriptionWhereInput;
  OR?: FamilySubscriptionWhereInput[] | FamilySubscriptionWhereInput;
  NOT?: FamilySubscriptionWhereInput[] | FamilySubscriptionWhereInput;
}

export interface WorkUpdateWithoutCompanyDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  department?: String;
  post?: String;
  jobContent?: String;
  worker?: UserUpdateOneWithoutWorksInput;
}

export interface AreaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AreaWhereInput;
  AND?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  OR?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
  NOT?: AreaSubscriptionWhereInput[] | AreaSubscriptionWhereInput;
}

export interface UserUpdateOneWithoutWorksInput {
  create?: UserCreateWithoutWorksInput;
  update?: UserUpdateWithoutWorksDataInput;
  upsert?: UserUpsertWithoutWorksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface WorkCreateInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyCreateOneWithoutWorksInput;
  department?: String;
  post?: String;
  jobContent?: String;
  worker?: UserCreateOneWithoutWorksInput;
}

export interface UserUpdateWithoutWorksDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutPeopleInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  uid?: String;
  token?: String;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput;
}

export interface ProvinceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  cities_every?: CityWhereInput;
  cities_some?: CityWhereInput;
  cities_none?: CityWhereInput;
  AND?: ProvinceWhereInput[] | ProvinceWhereInput;
  OR?: ProvinceWhereInput[] | ProvinceWhereInput;
  NOT?: ProvinceWhereInput[] | ProvinceWhereInput;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface PostUpdateWithoutAuthorDataInput {
  isPublished?: Boolean;
  title?: String;
  content?: String;
}

export type FamilyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface RegStatusUpdateOneWithoutApplicantsInput {
  create?: RegStatusCreateWithoutApplicantsInput;
  update?: RegStatusUpdateWithoutApplicantsDataInput;
  upsert?: RegStatusUpsertWithoutApplicantsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: RegStatusWhereUniqueInput;
}

export interface UserCreateManyWithoutStudiesInput {
  create?: UserCreateWithoutStudiesInput[] | UserCreateWithoutStudiesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface RegStatusUpdateWithoutApplicantsDataInput {
  university?: UniversityUpdateOneInput;
  major?: MajorUpdateOneRequiredInput;
}

export interface SchoolUpdateInput {
  name?: String;
  kind?: Educationkind;
  location?: LocationUpdateOneWithoutSchoolsInput;
}

export interface UniversityUpdateOneInput {
  create?: UniversityCreateInput;
  update?: UniversityUpdateDataInput;
  upsert?: UniversityUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UniversityWhereUniqueInput;
}

export interface UserUpdateWithWhereUniqueWithoutRegStatusInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutRegStatusDataInput;
}

export interface UniversityUpdateDataInput {
  name?: String;
  location?: LocationUpdateOneWithoutUniversitiesInput;
  major?: MajorUpdateManyWithoutUniversitiesInput;
}

export interface UserCreateWithoutRegStatusInput {
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationCreateOneWithoutPeopleInput;
  uid: String;
  token: String;
  posts?: PostCreateManyWithoutAuthorInput;
  families?: FamilyCreateManyWithoutFromInput;
  studies?: SchoolEduCreateManyWithoutStudentsInput;
  works?: WorkCreateManyWithoutWorkerInput;
}

export interface LocationUpdateOneWithoutUniversitiesInput {
  create?: LocationCreateWithoutUniversitiesInput;
  update?: LocationUpdateWithoutUniversitiesDataInput;
  upsert?: LocationUpsertWithoutUniversitiesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface ProvinceUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface LocationUpdateWithoutUniversitiesDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  people?: UserUpdateManyWithoutBirthplaceInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface UserUpdateManyWithoutBirthplaceInput {
  create?:
    | UserCreateWithoutBirthplaceInput[]
    | UserCreateWithoutBirthplaceInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutBirthplaceInput[]
    | UserUpdateWithWhereUniqueWithoutBirthplaceInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutBirthplaceInput[]
    | UserUpsertWithWhereUniqueWithoutBirthplaceInput;
}

export type SchoolWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithWhereUniqueWithoutBirthplaceInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutBirthplaceDataInput;
}

export type SchoolEduWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateWithoutBirthplaceDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
}

export type StreetWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface FamilyUpdateManyWithoutFromInput {
  create?: FamilyCreateWithoutFromInput[] | FamilyCreateWithoutFromInput;
  delete?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  disconnect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  update?:
    | FamilyUpdateWithWhereUniqueWithoutFromInput[]
    | FamilyUpdateWithWhereUniqueWithoutFromInput;
  upsert?:
    | FamilyUpsertWithWhereUniqueWithoutFromInput[]
    | FamilyUpsertWithWhereUniqueWithoutFromInput;
}

export type UniversityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface FamilyUpdateWithWhereUniqueWithoutFromInput {
  where: FamilyWhereUniqueInput;
  data: FamilyUpdateWithoutFromDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
  uid?: String;
  token?: String;
}>;

export interface FamilyUpdateWithoutFromDataInput {
  to?: PersonUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export type VillageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
}>;

export interface PersonUpdateOneRequiredWithoutFamiliesInput {
  create?: PersonCreateWithoutFamiliesInput;
  update?: PersonUpdateWithoutFamiliesDataInput;
  upsert?: PersonUpsertWithoutFamiliesInput;
  connect?: PersonWhereUniqueInput;
}

export type WorkWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PersonUpdateWithoutFamiliesDataInput {
  name?: String;
  user?: UserUpdateOneInput;
}

export interface ProvinceCreateOneWithoutCitiesInput {
  create?: ProvinceCreateWithoutCitiesInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface VillageCreateManyWithoutStreetInput {
  create?: VillageCreateWithoutStreetInput[] | VillageCreateWithoutStreetInput;
  connect?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface CityUpdateWithoutAreasDataInput {
  code?: String;
  name?: String;
  province?: ProvinceUpdateOneRequiredWithoutCitiesInput;
}

export interface PersonUpsertWithoutFamiliesInput {
  update: PersonUpdateWithoutFamiliesDataInput;
  create: PersonCreateWithoutFamiliesInput;
}

export interface CityUpsertWithoutAreasInput {
  update: CityUpdateWithoutAreasDataInput;
  create: CityCreateWithoutAreasInput;
}

export interface FamilyUpdateOneInput {
  create?: FamilyCreateInput;
  update?: FamilyUpdateDataInput;
  upsert?: FamilyUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FamilyWhereUniqueInput;
}

export interface VillageUpdateManyWithoutStreetInput {
  create?: VillageCreateWithoutStreetInput[] | VillageCreateWithoutStreetInput;
  delete?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
  connect?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
  disconnect?: VillageWhereUniqueInput[] | VillageWhereUniqueInput;
  update?:
    | VillageUpdateWithWhereUniqueWithoutStreetInput[]
    | VillageUpdateWithWhereUniqueWithoutStreetInput;
  upsert?:
    | VillageUpsertWithWhereUniqueWithoutStreetInput[]
    | VillageUpsertWithWhereUniqueWithoutStreetInput;
}

export interface FamilyUpdateDataInput {
  from?: UserUpdateOneRequiredWithoutFamiliesInput;
  to?: PersonUpdateOneRequiredWithoutFamiliesInput;
  relationship?: String;
  spouse?: FamilyUpdateOneInput;
  status?: String;
}

export interface StreetUpsertWithWhereUniqueWithoutAreaInput {
  where: StreetWhereUniqueInput;
  update: StreetUpdateWithoutAreaDataInput;
  create: StreetCreateWithoutAreaInput;
}

export interface UserUpdateOneRequiredWithoutFamiliesInput {
  create?: UserCreateWithoutFamiliesInput;
  update?: UserUpdateWithoutFamiliesDataInput;
  upsert?: UserUpsertWithoutFamiliesInput;
  connect?: UserWhereUniqueInput;
}

export interface CityCreateInput {
  code: String;
  name: String;
  province: ProvinceCreateOneWithoutCitiesInput;
  areas?: AreaCreateManyWithoutCityInput;
}

export interface UserUpdateWithoutFamiliesDataInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutPeopleInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
}

export interface AreaUpdateManyWithoutCityInput {
  create?: AreaCreateWithoutCityInput[] | AreaCreateWithoutCityInput;
  delete?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  connect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  disconnect?: AreaWhereUniqueInput[] | AreaWhereUniqueInput;
  update?:
    | AreaUpdateWithWhereUniqueWithoutCityInput[]
    | AreaUpdateWithWhereUniqueWithoutCityInput;
  upsert?:
    | AreaUpsertWithWhereUniqueWithoutCityInput[]
    | AreaUpsertWithWhereUniqueWithoutCityInput;
}

export interface SchoolEduUpdateManyWithoutStudentsInput {
  create?:
    | SchoolEduCreateWithoutStudentsInput[]
    | SchoolEduCreateWithoutStudentsInput;
  delete?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
  connect?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
  disconnect?: SchoolEduWhereUniqueInput[] | SchoolEduWhereUniqueInput;
  update?:
    | SchoolEduUpdateWithWhereUniqueWithoutStudentsInput[]
    | SchoolEduUpdateWithWhereUniqueWithoutStudentsInput;
  upsert?:
    | SchoolEduUpsertWithWhereUniqueWithoutStudentsInput[]
    | SchoolEduUpsertWithWhereUniqueWithoutStudentsInput;
}

export interface CityUpdateManyMutationInput {
  code?: String;
  name?: String;
}

export interface SchoolEduUpdateWithWhereUniqueWithoutStudentsInput {
  where: SchoolEduWhereUniqueInput;
  data: SchoolEduUpdateWithoutStudentsDataInput;
}

export interface CityCreateManyWithoutProvinceInput {
  create?: CityCreateWithoutProvinceInput[] | CityCreateWithoutProvinceInput;
  connect?: CityWhereUniqueInput[] | CityWhereUniqueInput;
}

export interface SchoolEduUpdateWithoutStudentsDataInput {
  school?: SchoolUpdateOneInput;
  startTime?: DateTimeInput;
  major?: MajorUpdateOneInput;
  grade?: Int;
  className?: String;
}

export interface LocationCreateOneWithoutPeopleInput {
  create?: LocationCreateWithoutPeopleInput;
  connect?: LocationWhereUniqueInput;
}

export interface SchoolUpdateOneInput {
  create?: SchoolCreateInput;
  update?: SchoolUpdateDataInput;
  upsert?: SchoolUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SchoolWhereUniqueInput;
}

export interface StreetCreateOneInput {
  create?: StreetCreateInput;
  connect?: StreetWhereUniqueInput;
}

export interface SchoolUpdateDataInput {
  name?: String;
  kind?: Educationkind;
  location?: LocationUpdateOneWithoutSchoolsInput;
}

export interface WorkSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WorkWhereInput;
  AND?: WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput;
  OR?: WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput;
  NOT?: WorkSubscriptionWhereInput[] | WorkSubscriptionWhereInput;
}

export interface LocationUpdateOneWithoutSchoolsInput {
  create?: LocationCreateWithoutSchoolsInput;
  update?: LocationUpdateWithoutSchoolsDataInput;
  upsert?: LocationUpsertWithoutSchoolsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface RegStatusSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RegStatusWhereInput;
  AND?: RegStatusSubscriptionWhereInput[] | RegStatusSubscriptionWhereInput;
  OR?: RegStatusSubscriptionWhereInput[] | RegStatusSubscriptionWhereInput;
  NOT?: RegStatusSubscriptionWhereInput[] | RegStatusSubscriptionWhereInput;
}

export interface LocationUpdateWithoutSchoolsDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  companies?: CompanyUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyWithoutLocationInput;
  people?: UserUpdateManyWithoutBirthplaceInput;
}

export interface RegStatusWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  university?: UniversityWhereInput;
  major?: MajorWhereInput;
  applicants_every?: UserWhereInput;
  applicants_some?: UserWhereInput;
  applicants_none?: UserWhereInput;
  AND?: RegStatusWhereInput[] | RegStatusWhereInput;
  OR?: RegStatusWhereInput[] | RegStatusWhereInput;
  NOT?: RegStatusWhereInput[] | RegStatusWhereInput;
}

export interface UniversityUpdateManyWithoutLocationInput {
  create?:
    | UniversityCreateWithoutLocationInput[]
    | UniversityCreateWithoutLocationInput;
  delete?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  connect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  disconnect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  update?:
    | UniversityUpdateWithWhereUniqueWithoutLocationInput[]
    | UniversityUpdateWithWhereUniqueWithoutLocationInput;
  upsert?:
    | UniversityUpsertWithWhereUniqueWithoutLocationInput[]
    | UniversityUpsertWithWhereUniqueWithoutLocationInput;
}

export interface MajorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MajorWhereInput;
  AND?: MajorSubscriptionWhereInput[] | MajorSubscriptionWhereInput;
  OR?: MajorSubscriptionWhereInput[] | MajorSubscriptionWhereInput;
  NOT?: MajorSubscriptionWhereInput[] | MajorSubscriptionWhereInput;
}

export interface UniversityUpdateWithWhereUniqueWithoutLocationInput {
  where: UniversityWhereUniqueInput;
  data: UniversityUpdateWithoutLocationDataInput;
}

export interface WorkUpdateInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyUpdateOneWithoutWorksInput;
  department?: String;
  post?: String;
  jobContent?: String;
  worker?: UserUpdateOneWithoutWorksInput;
}

export interface UniversityUpdateWithoutLocationDataInput {
  name?: String;
  major?: MajorUpdateManyWithoutUniversitiesInput;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeInput;
  birthplace?: LocationUpdateOneWithoutPeopleInput;
  uid?: String;
  token?: String;
  posts?: PostUpdateManyWithoutAuthorInput;
  regStatus?: RegStatusUpdateOneWithoutApplicantsInput;
  families?: FamilyUpdateManyWithoutFromInput;
  studies?: SchoolEduUpdateManyWithoutStudentsInput;
  works?: WorkUpdateManyWithoutWorkerInput;
}

export interface MajorUpdateManyWithoutUniversitiesInput {
  create?:
    | MajorCreateWithoutUniversitiesInput[]
    | MajorCreateWithoutUniversitiesInput;
  delete?: MajorWhereUniqueInput[] | MajorWhereUniqueInput;
  connect?: MajorWhereUniqueInput[] | MajorWhereUniqueInput;
  disconnect?: MajorWhereUniqueInput[] | MajorWhereUniqueInput;
  update?:
    | MajorUpdateWithWhereUniqueWithoutUniversitiesInput[]
    | MajorUpdateWithWhereUniqueWithoutUniversitiesInput;
  upsert?:
    | MajorUpsertWithWhereUniqueWithoutUniversitiesInput[]
    | MajorUpsertWithWhereUniqueWithoutUniversitiesInput;
}

export interface SchoolEduUpdateManyMutationInput {
  startTime?: DateTimeInput;
  grade?: Int;
  className?: String;
}

export interface MajorUpdateWithWhereUniqueWithoutUniversitiesInput {
  where: MajorWhereUniqueInput;
  data: MajorUpdateWithoutUniversitiesDataInput;
}

export interface SchoolEduUpdateInput {
  school?: SchoolUpdateOneInput;
  startTime?: DateTimeInput;
  major?: MajorUpdateOneInput;
  grade?: Int;
  className?: String;
  students?: UserUpdateManyWithoutStudiesInput;
}

export interface MajorUpdateWithoutUniversitiesDataInput {
  name?: String;
  category?: String;
  education?: Educationkind;
}

export interface UserUpsertWithWhereUniqueWithoutRegStatusInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutRegStatusDataInput;
  create: UserCreateWithoutRegStatusInput;
}

export interface MajorUpsertWithWhereUniqueWithoutUniversitiesInput {
  where: MajorWhereUniqueInput;
  update: MajorUpdateWithoutUniversitiesDataInput;
  create: MajorCreateWithoutUniversitiesInput;
}

export type ProvinceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  code?: String;
  name?: String;
}>;

export interface UniversityUpsertWithWhereUniqueWithoutLocationInput {
  where: UniversityWhereUniqueInput;
  update: UniversityUpdateWithoutLocationDataInput;
  create: UniversityCreateWithoutLocationInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  update?: UserUpdateWithoutPostsDataInput;
  upsert?: UserUpsertWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface LocationUpsertWithoutSchoolsInput {
  update: LocationUpdateWithoutSchoolsDataInput;
  create: LocationCreateWithoutSchoolsInput;
}

export interface FamilyUpsertWithWhereUniqueWithoutToInput {
  where: FamilyWhereUniqueInput;
  update: FamilyUpdateWithoutToDataInput;
  create: FamilyCreateWithoutToInput;
}

export interface SchoolUpsertNestedInput {
  update: SchoolUpdateDataInput;
  create: SchoolCreateInput;
}

export interface FamilyCreateManyWithoutToInput {
  create?: FamilyCreateWithoutToInput[] | FamilyCreateWithoutToInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
}

export interface MajorUpdateOneInput {
  create?: MajorCreateInput;
  update?: MajorUpdateDataInput;
  upsert?: MajorUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MajorWhereUniqueInput;
}

export interface LocationCreateInput {
  name?: String;
  province?: ProvinceCreateOneInput;
  city?: CityCreateOneInput;
  area?: AreaCreateOneInput;
  street?: StreetCreateOneInput;
  village?: VillageCreateOneInput;
  schools?: SchoolCreateManyWithoutLocationInput;
  companies?: CompanyCreateManyWithoutLocationInput;
  universities?: UniversityCreateManyWithoutLocationInput;
  people?: UserCreateManyWithoutBirthplaceInput;
}

export interface MajorUpdateDataInput {
  name?: String;
  category?: String;
  education?: Educationkind;
  universities?: UniversityUpdateManyWithoutMajorInput;
}

export interface CityCreateOneWithoutAreasInput {
  create?: CityCreateWithoutAreasInput;
  connect?: CityWhereUniqueInput;
}

export interface UniversityUpdateManyWithoutMajorInput {
  create?:
    | UniversityCreateWithoutMajorInput[]
    | UniversityCreateWithoutMajorInput;
  delete?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  connect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  disconnect?: UniversityWhereUniqueInput[] | UniversityWhereUniqueInput;
  update?:
    | UniversityUpdateWithWhereUniqueWithoutMajorInput[]
    | UniversityUpdateWithWhereUniqueWithoutMajorInput;
  upsert?:
    | UniversityUpsertWithWhereUniqueWithoutMajorInput[]
    | UniversityUpsertWithWhereUniqueWithoutMajorInput;
}

export interface AreaUpdateInput {
  code?: String;
  name?: String;
  city?: CityUpdateOneRequiredWithoutAreasInput;
  towns?: StreetUpdateManyWithoutAreaInput;
}

export interface UniversityUpdateWithWhereUniqueWithoutMajorInput {
  where: UniversityWhereUniqueInput;
  data: UniversityUpdateWithoutMajorDataInput;
}

export interface StreetUpdateWithWhereUniqueWithoutAreaInput {
  where: StreetWhereUniqueInput;
  data: StreetUpdateWithoutAreaDataInput;
}

export interface UniversityUpdateWithoutMajorDataInput {
  name?: String;
  location?: LocationUpdateOneWithoutUniversitiesInput;
}

export interface CompanyCreateInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationCreateOneWithoutCompaniesInput;
  BusinessScope?: String;
  works?: WorkCreateManyWithoutCompanyInput;
}

export interface UniversityUpsertWithWhereUniqueWithoutMajorInput {
  where: UniversityWhereUniqueInput;
  update: UniversityUpdateWithoutMajorDataInput;
  create: UniversityCreateWithoutMajorInput;
}

export interface AreaUpdateWithoutCityDataInput {
  code?: String;
  name?: String;
  towns?: StreetUpdateManyWithoutAreaInput;
}

export interface MajorUpsertNestedInput {
  update: MajorUpdateDataInput;
  create: MajorCreateInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface SchoolEduUpsertWithWhereUniqueWithoutStudentsInput {
  where: SchoolEduWhereUniqueInput;
  update: SchoolEduUpdateWithoutStudentsDataInput;
  create: SchoolEduCreateWithoutStudentsInput;
}

export interface AreaCreateOneWithoutTownsInput {
  create?: AreaCreateWithoutTownsInput;
  connect?: AreaWhereUniqueInput;
}

export interface WorkUpdateManyWithoutWorkerInput {
  create?: WorkCreateWithoutWorkerInput[] | WorkCreateWithoutWorkerInput;
  delete?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  connect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  disconnect?: WorkWhereUniqueInput[] | WorkWhereUniqueInput;
  update?:
    | WorkUpdateWithWhereUniqueWithoutWorkerInput[]
    | WorkUpdateWithWhereUniqueWithoutWorkerInput;
  upsert?:
    | WorkUpsertWithWhereUniqueWithoutWorkerInput[]
    | WorkUpsertWithWhereUniqueWithoutWorkerInput;
}

export interface CompanyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  establishmentDate?: DateTimeInput;
  establishmentDate_not?: DateTimeInput;
  establishmentDate_in?: DateTimeInput[] | DateTimeInput;
  establishmentDate_not_in?: DateTimeInput[] | DateTimeInput;
  establishmentDate_lt?: DateTimeInput;
  establishmentDate_lte?: DateTimeInput;
  establishmentDate_gt?: DateTimeInput;
  establishmentDate_gte?: DateTimeInput;
  representative?: String;
  representative_not?: String;
  representative_in?: String[] | String;
  representative_not_in?: String[] | String;
  representative_lt?: String;
  representative_lte?: String;
  representative_gt?: String;
  representative_gte?: String;
  representative_contains?: String;
  representative_not_contains?: String;
  representative_starts_with?: String;
  representative_not_starts_with?: String;
  representative_ends_with?: String;
  representative_not_ends_with?: String;
  location?: LocationWhereInput;
  BusinessScope?: String;
  BusinessScope_not?: String;
  BusinessScope_in?: String[] | String;
  BusinessScope_not_in?: String[] | String;
  BusinessScope_lt?: String;
  BusinessScope_lte?: String;
  BusinessScope_gt?: String;
  BusinessScope_gte?: String;
  BusinessScope_contains?: String;
  BusinessScope_not_contains?: String;
  BusinessScope_starts_with?: String;
  BusinessScope_not_starts_with?: String;
  BusinessScope_ends_with?: String;
  BusinessScope_not_ends_with?: String;
  works_every?: WorkWhereInput;
  works_some?: WorkWhereInput;
  works_none?: WorkWhereInput;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export interface WorkUpdateWithWhereUniqueWithoutWorkerInput {
  where: WorkWhereUniqueInput;
  data: WorkUpdateWithoutWorkerDataInput;
}

export interface CollegeEntranceExamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CollegeEntranceExamWhereInput;
  AND?:
    | CollegeEntranceExamSubscriptionWhereInput[]
    | CollegeEntranceExamSubscriptionWhereInput;
  OR?:
    | CollegeEntranceExamSubscriptionWhereInput[]
    | CollegeEntranceExamSubscriptionWhereInput;
  NOT?:
    | CollegeEntranceExamSubscriptionWhereInput[]
    | CollegeEntranceExamSubscriptionWhereInput;
}

export interface WorkUpdateWithoutWorkerDataInput {
  startTime?: DateTimeInput;
  endTime?: DateTimeInput;
  company?: CompanyUpdateOneWithoutWorksInput;
  department?: String;
  post?: String;
  jobContent?: String;
}

export interface UniversityUpdateInput {
  name?: String;
  location?: LocationUpdateOneWithoutUniversitiesInput;
  major?: MajorUpdateManyWithoutUniversitiesInput;
}

export interface CompanyUpdateOneWithoutWorksInput {
  create?: CompanyCreateWithoutWorksInput;
  update?: CompanyUpdateWithoutWorksDataInput;
  upsert?: CompanyUpsertWithoutWorksInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export interface SchoolEduCreateInput {
  school?: SchoolCreateOneInput;
  startTime?: DateTimeInput;
  major?: MajorCreateOneInput;
  grade?: Int;
  className?: String;
  students?: UserCreateManyWithoutStudiesInput;
}

export interface CompanyUpdateWithoutWorksDataInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  location?: LocationUpdateOneWithoutCompaniesInput;
  BusinessScope?: String;
}

export interface PostUpdateManyMutationInput {
  isPublished?: Boolean;
  title?: String;
  content?: String;
}

export interface LocationUpdateOneWithoutCompaniesInput {
  create?: LocationCreateWithoutCompaniesInput;
  update?: LocationUpdateWithoutCompaniesDataInput;
  upsert?: LocationUpsertWithoutCompaniesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: LocationWhereUniqueInput;
}

export interface FamilyUpdateManyWithoutToInput {
  create?: FamilyCreateWithoutToInput[] | FamilyCreateWithoutToInput;
  delete?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  connect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  disconnect?: FamilyWhereUniqueInput[] | FamilyWhereUniqueInput;
  update?:
    | FamilyUpdateWithWhereUniqueWithoutToInput[]
    | FamilyUpdateWithWhereUniqueWithoutToInput;
  upsert?:
    | FamilyUpsertWithWhereUniqueWithoutToInput[]
    | FamilyUpsertWithWhereUniqueWithoutToInput;
}

export interface LocationUpdateWithoutCompaniesDataInput {
  name?: String;
  province?: ProvinceUpdateOneInput;
  city?: CityUpdateOneInput;
  area?: AreaUpdateOneInput;
  street?: StreetUpdateOneInput;
  village?: VillageUpdateOneInput;
  schools?: SchoolUpdateManyWithoutLocationInput;
  universities?: UniversityUpdateManyWithoutLocationInput;
  people?: UserUpdateManyWithoutBirthplaceInput;
}

export interface CompanyUpdateManyMutationInput {
  name?: String;
  code?: String;
  establishmentDate?: DateTimeInput;
  representative?: String;
  BusinessScope?: String;
}

export interface LocationUpsertWithoutCompaniesInput {
  update: LocationUpdateWithoutCompaniesDataInput;
  create: LocationCreateWithoutCompaniesInput;
}

export interface ProvinceUpdateWithoutCitiesDataInput {
  code?: String;
  name?: String;
}

export interface CompanyUpsertWithoutWorksInput {
  update: CompanyUpdateWithoutWorksDataInput;
  create: CompanyCreateWithoutWorksInput;
}

export interface AreaCreateWithoutCityInput {
  code: String;
  name: String;
  towns?: StreetCreateManyWithoutAreaInput;
}

export interface WorkUpsertWithWhereUniqueWithoutWorkerInput {
  where: WorkWhereUniqueInput;
  update: WorkUpdateWithoutWorkerDataInput;
  create: WorkCreateWithoutWorkerInput;
}

export interface CityCreateOneInput {
  create?: CityCreateInput;
  connect?: CityWhereUniqueInput;
}

export interface UserUpsertWithoutFamiliesInput {
  update: UserUpdateWithoutFamiliesDataInput;
  create: UserCreateWithoutFamiliesInput;
}

export interface PersonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  user?: UserWhereInput;
  families_every?: FamilyWhereInput;
  families_some?: FamilyWhereInput;
  families_none?: FamilyWhereInput;
  AND?: PersonWhereInput[] | PersonWhereInput;
  OR?: PersonWhereInput[] | PersonWhereInput;
  NOT?: PersonWhereInput[] | PersonWhereInput;
}

export interface FamilyUpsertNestedInput {
  update: FamilyUpdateDataInput;
  create: FamilyCreateInput;
}

export interface UserUpdateWithWhereUniqueWithoutStudiesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutStudiesDataInput;
}

export interface FamilyUpsertWithWhereUniqueWithoutFromInput {
  where: FamilyWhereUniqueInput;
  update: FamilyUpdateWithoutFromDataInput;
  create: FamilyCreateWithoutFromInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutBirthplaceInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutBirthplaceDataInput;
  create: UserCreateWithoutBirthplaceInput;
}

export interface StreetCreateManyWithoutAreaInput {
  create?: StreetCreateWithoutAreaInput[] | StreetCreateWithoutAreaInput;
  connect?: StreetWhereUniqueInput[] | StreetWhereUniqueInput;
}

export interface LocationUpsertWithoutUniversitiesInput {
  update: LocationUpdateWithoutUniversitiesDataInput;
  create: LocationCreateWithoutUniversitiesInput;
}

export interface ProvinceCreateOneInput {
  create?: ProvinceCreateInput;
  connect?: ProvinceWhereUniqueInput;
}

export interface UniversityUpsertNestedInput {
  update: UniversityUpdateDataInput;
  create: UniversityCreateInput;
}

export interface StreetWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  code?: String;
  code_not?: String;
  code_in?: String[] | String;
  code_not_in?: String[] | String;
  code_lt?: String;
  code_lte?: String;
  code_gt?: String;
  code_gte?: String;
  code_contains?: String;
  code_not_contains?: String;
  code_starts_with?: String;
  code_not_starts_with?: String;
  code_ends_with?: String;
  code_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  Area?: AreaWhereInput;
  villages_every?: VillageWhereInput;
  villages_some?: VillageWhereInput;
  villages_none?: VillageWhereInput;
  AND?: StreetWhereInput[] | StreetWhereInput;
  OR?: StreetWhereInput[] | StreetWhereInput;
  NOT?: StreetWhereInput[] | StreetWhereInput;
}

export interface WorkUpsertWithWhereUniqueWithoutCompanyInput {
  where: WorkWhereUniqueInput;
  update: WorkUpdateWithoutCompanyDataInput;
  create: WorkCreateWithoutCompanyInput;
}

export interface UserUpsertWithoutWorksInput {
  update: UserUpdateWithoutWorksDataInput;
  create: UserCreateWithoutWorksInput;
}

export interface RegStatusUpsertWithoutApplicantsInput {
  update: RegStatusUpdateWithoutApplicantsDataInput;
  create: RegStatusCreateWithoutApplicantsInput;
}

export interface MajorUpdateOneRequiredInput {
  create?: MajorCreateInput;
  update?: MajorUpdateDataInput;
  upsert?: MajorUpsertNestedInput;
  connect?: MajorWhereUniqueInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UniversitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UniversityWhereInput;
  AND?: UniversitySubscriptionWhereInput[] | UniversitySubscriptionWhereInput;
  OR?: UniversitySubscriptionWhereInput[] | UniversitySubscriptionWhereInput;
  NOT?: UniversitySubscriptionWhereInput[] | UniversitySubscriptionWhereInput;
}

export interface VillageUpdateWithoutStreetDataInput {
  code?: String;
  name?: String;
}

export interface MajorUpdateInput {
  name?: String;
  category?: String;
  education?: Educationkind;
  universities?: UniversityUpdateManyWithoutMajorInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface WorkPreviousValues {
  id: ID_Output;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  department?: String;
  post?: String;
  jobContent?: String;
}

export interface WorkPreviousValuesPromise
  extends Promise<WorkPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  department: () => Promise<String>;
  post: () => Promise<String>;
  jobContent: () => Promise<String>;
}

export interface WorkPreviousValuesSubscription
  extends Promise<AsyncIterator<WorkPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  department: () => Promise<AsyncIterator<String>>;
  post: () => Promise<AsyncIterator<String>>;
  jobContent: () => Promise<AsyncIterator<String>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isPublished: Boolean;
  title: String;
  content: String;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  isPublished: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
}

export interface AggregateArea {
  count: Int;
}

export interface AggregateAreaPromise
  extends Promise<AggregateArea>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAreaSubscription
  extends Promise<AsyncIterator<AggregateArea>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Family {
  id: ID_Output;
  relationship: String;
  status: String;
}

export interface FamilyPromise extends Promise<Family>, Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = UserPromise>() => T;
  to: <T = PersonPromise>() => T;
  relationship: () => Promise<String>;
  spouse: <T = FamilyPromise>() => T;
  status: () => Promise<String>;
}

export interface FamilySubscription
  extends Promise<AsyncIterator<Family>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = UserSubscription>() => T;
  to: <T = PersonSubscription>() => T;
  relationship: () => Promise<AsyncIterator<String>>;
  spouse: <T = FamilySubscription>() => T;
  status: () => Promise<AsyncIterator<String>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeOutput;
  uid: String;
  token: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  avatar: () => Promise<String>;
  birthdaycalendar: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  uid: () => Promise<String>;
  token: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  birthdaycalendar: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  uid: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RegStatus {
  id: ID_Output;
}

export interface RegStatusPromise extends Promise<RegStatus>, Fragmentable {
  id: () => Promise<ID_Output>;
  university: <T = UniversityPromise>() => T;
  major: <T = MajorPromise>() => T;
  applicants: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RegStatusSubscription
  extends Promise<AsyncIterator<RegStatus>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  university: <T = UniversitySubscription>() => T;
  major: <T = MajorSubscription>() => T;
  applicants: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface WorkSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface WorkSubscriptionPayloadPromise
  extends Promise<WorkSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WorkPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WorkPreviousValuesPromise>() => T;
}

export interface WorkSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WorkSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WorkSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WorkPreviousValuesSubscription>() => T;
}

export interface WorkConnection {}

export interface WorkConnectionPromise
  extends Promise<WorkConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WorkEdge>>() => T;
  aggregate: <T = AggregateWorkPromise>() => T;
}

export interface WorkConnectionSubscription
  extends Promise<AsyncIterator<WorkConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WorkEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWorkSubscription>() => T;
}

export interface AggregateWork {
  count: Int;
}

export interface AggregateWorkPromise
  extends Promise<AggregateWork>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWorkSubscription
  extends Promise<AsyncIterator<AggregateWork>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VillageEdge {
  cursor: String;
}

export interface VillageEdgePromise extends Promise<VillageEdge>, Fragmentable {
  node: <T = VillagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VillageEdgeSubscription
  extends Promise<AsyncIterator<VillageEdge>>,
    Fragmentable {
  node: <T = VillageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Major {
  id: ID_Output;
  name: String;
  category: String;
  education: Educationkind;
}

export interface MajorPromise extends Promise<Major>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<String>;
  education: () => Promise<Educationkind>;
  universities: <T = FragmentableArray<University>>(
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MajorSubscription
  extends Promise<AsyncIterator<Major>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
  universities: <T = Promise<AsyncIterator<UniversitySubscription>>>(
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Street {
  id: ID_Output;
  code: String;
  name: String;
}

export interface StreetPromise extends Promise<Street>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  Area: <T = AreaPromise>() => T;
  villages: <T = FragmentableArray<Village>>(
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StreetSubscription
  extends Promise<AsyncIterator<Street>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  Area: <T = AreaSubscription>() => T;
  villages: <T = Promise<AsyncIterator<VillageSubscription>>>(
    args?: {
      where?: VillageWhereInput;
      orderBy?: VillageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CityConnection {}

export interface CityConnectionPromise
  extends Promise<CityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CityEdge>>() => T;
  aggregate: <T = AggregateCityPromise>() => T;
}

export interface CityConnectionSubscription
  extends Promise<AsyncIterator<CityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCitySubscription>() => T;
}

export interface UniversityEdge {
  cursor: String;
}

export interface UniversityEdgePromise
  extends Promise<UniversityEdge>,
    Fragmentable {
  node: <T = UniversityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UniversityEdgeSubscription
  extends Promise<AsyncIterator<UniversityEdge>>,
    Fragmentable {
  node: <T = UniversitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AreaSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AreaSubscriptionPayloadPromise
  extends Promise<AreaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AreaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AreaPreviousValuesPromise>() => T;
}

export interface AreaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AreaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AreaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AreaPreviousValuesSubscription>() => T;
}

export interface AggregateStreet {
  count: Int;
}

export interface AggregateStreetPromise
  extends Promise<AggregateStreet>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStreetSubscription
  extends Promise<AsyncIterator<AggregateStreet>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AreaPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface AreaPreviousValuesPromise
  extends Promise<AreaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AreaPreviousValuesSubscription
  extends Promise<AsyncIterator<AreaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StreetConnection {}

export interface StreetConnectionPromise
  extends Promise<StreetConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StreetEdge>>() => T;
  aggregate: <T = AggregateStreetPromise>() => T;
}

export interface StreetConnectionSubscription
  extends Promise<AsyncIterator<StreetConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StreetEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStreetSubscription>() => T;
}

export interface University {
  id: ID_Output;
  name: String;
}

export interface UniversityPromise extends Promise<University>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  major: <T = FragmentableArray<Major>>(
    args?: {
      where?: MajorWhereInput;
      orderBy?: MajorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UniversitySubscription
  extends Promise<AsyncIterator<University>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  major: <T = Promise<AsyncIterator<MajorSubscription>>>(
    args?: {
      where?: MajorWhereInput;
      orderBy?: MajorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SchoolEduEdge {
  cursor: String;
}

export interface SchoolEduEdgePromise
  extends Promise<SchoolEduEdge>,
    Fragmentable {
  node: <T = SchoolEduPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolEduEdgeSubscription
  extends Promise<AsyncIterator<SchoolEduEdge>>,
    Fragmentable {
  node: <T = SchoolEduSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CitySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CitySubscriptionPayloadPromise
  extends Promise<CitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CityPreviousValuesPromise>() => T;
}

export interface CitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CityPreviousValuesSubscription>() => T;
}

export interface AggregateSchool {
  count: Int;
}

export interface AggregateSchoolPromise
  extends Promise<AggregateSchool>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolSubscription
  extends Promise<AsyncIterator<AggregateSchool>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface CityPreviousValuesPromise
  extends Promise<CityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface CityPreviousValuesSubscription
  extends Promise<AsyncIterator<CityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SchoolConnection {}

export interface SchoolConnectionPromise
  extends Promise<SchoolConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolEdge>>() => T;
  aggregate: <T = AggregateSchoolPromise>() => T;
}

export interface SchoolConnectionSubscription
  extends Promise<AsyncIterator<SchoolConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolSubscription>() => T;
}

export interface Village {
  id: ID_Output;
  code: String;
  name: String;
}

export interface VillagePromise extends Promise<Village>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  street: <T = StreetPromise>() => T;
}

export interface VillageSubscription
  extends Promise<AsyncIterator<Village>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  street: <T = StreetSubscription>() => T;
}

export interface RegStatusEdge {
  cursor: String;
}

export interface RegStatusEdgePromise
  extends Promise<RegStatusEdge>,
    Fragmentable {
  node: <T = RegStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegStatusEdgeSubscription
  extends Promise<AsyncIterator<RegStatusEdge>>,
    Fragmentable {
  node: <T = RegStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollegeEntranceExamSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CollegeEntranceExamSubscriptionPayloadPromise
  extends Promise<CollegeEntranceExamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CollegeEntranceExamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CollegeEntranceExamPreviousValuesPromise>() => T;
}

export interface CollegeEntranceExamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CollegeEntranceExamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CollegeEntranceExamPreviousValuesSubscription>() => T;
}

export interface Area {
  id: ID_Output;
  code: String;
  name: String;
}

export interface AreaPromise extends Promise<Area>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  city: <T = CityPromise>() => T;
  towns: <T = FragmentableArray<Street>>(
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AreaSubscription
  extends Promise<AsyncIterator<Area>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  city: <T = CitySubscription>() => T;
  towns: <T = Promise<AsyncIterator<StreetSubscription>>>(
    args?: {
      where?: StreetWhereInput;
      orderBy?: StreetOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CollegeEntranceExamPreviousValues {
  id: ID_Output;
  subject: String;
  culscore: Float;
  proscore?: Float;
  candidatenum: String;
  times?: Int;
}

export interface CollegeEntranceExamPreviousValuesPromise
  extends Promise<CollegeEntranceExamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subject: () => Promise<String>;
  culscore: () => Promise<Float>;
  proscore: () => Promise<Float>;
  candidatenum: () => Promise<String>;
  times: () => Promise<Int>;
}

export interface CollegeEntranceExamPreviousValuesSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subject: () => Promise<AsyncIterator<String>>;
  culscore: () => Promise<AsyncIterator<Float>>;
  proscore: () => Promise<AsyncIterator<Float>>;
  candidatenum: () => Promise<AsyncIterator<String>>;
  times: () => Promise<AsyncIterator<Int>>;
}

export interface ProvinceEdge {
  cursor: String;
}

export interface ProvinceEdgePromise
  extends Promise<ProvinceEdge>,
    Fragmentable {
  node: <T = ProvincePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProvinceEdgeSubscription
  extends Promise<AsyncIterator<ProvinceEdge>>,
    Fragmentable {
  node: <T = ProvinceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Work {
  id: ID_Output;
  startTime?: DateTimeOutput;
  endTime?: DateTimeOutput;
  department?: String;
  post?: String;
  jobContent?: String;
}

export interface WorkPromise extends Promise<Work>, Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  endTime: () => Promise<DateTimeOutput>;
  company: <T = CompanyPromise>() => T;
  department: () => Promise<String>;
  post: () => Promise<String>;
  jobContent: () => Promise<String>;
  worker: <T = UserPromise>() => T;
}

export interface WorkSubscription
  extends Promise<AsyncIterator<Work>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  endTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  company: <T = CompanySubscription>() => T;
  department: () => Promise<AsyncIterator<String>>;
  post: () => Promise<AsyncIterator<String>>;
  jobContent: () => Promise<AsyncIterator<String>>;
  worker: <T = UserSubscription>() => T;
}

export interface City {
  id: ID_Output;
  code: String;
  name: String;
}

export interface CityPromise extends Promise<City>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  province: <T = ProvincePromise>() => T;
  areas: <T = FragmentableArray<Area>>(
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CitySubscription
  extends Promise<AsyncIterator<City>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  province: <T = ProvinceSubscription>() => T;
  areas: <T = Promise<AsyncIterator<AreaSubscription>>>(
    args?: {
      where?: AreaWhereInput;
      orderBy?: AreaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface PostEdge {
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name?: String;
  code?: String;
  establishmentDate?: DateTimeOutput;
  representative?: String;
  BusinessScope?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  establishmentDate: () => Promise<DateTimeOutput>;
  representative: () => Promise<String>;
  BusinessScope: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  establishmentDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  representative: () => Promise<AsyncIterator<String>>;
  BusinessScope: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AreaConnection {}

export interface AreaConnectionPromise
  extends Promise<AreaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AreaEdge>>() => T;
  aggregate: <T = AggregateAreaPromise>() => T;
}

export interface AreaConnectionSubscription
  extends Promise<AsyncIterator<AreaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AreaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAreaSubscription>() => T;
}

export interface PersonConnection {}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface FamilySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FamilySubscriptionPayloadPromise
  extends Promise<FamilySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FamilyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FamilyPreviousValuesPromise>() => T;
}

export interface FamilySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FamilySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FamilySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FamilyPreviousValuesSubscription>() => T;
}

export interface AggregateMajor {
  count: Int;
}

export interface AggregateMajorPromise
  extends Promise<AggregateMajor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMajorSubscription
  extends Promise<AsyncIterator<AggregateMajor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FamilyPreviousValues {
  id: ID_Output;
  relationship: String;
  status: String;
}

export interface FamilyPreviousValuesPromise
  extends Promise<FamilyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  relationship: () => Promise<String>;
  status: () => Promise<String>;
}

export interface FamilyPreviousValuesSubscription
  extends Promise<AsyncIterator<FamilyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  relationship: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface MajorConnection {}

export interface MajorConnectionPromise
  extends Promise<MajorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MajorEdge>>() => T;
  aggregate: <T = AggregateMajorPromise>() => T;
}

export interface MajorConnectionSubscription
  extends Promise<AsyncIterator<MajorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MajorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMajorSubscription>() => T;
}

export interface Company {
  id: ID_Output;
  name?: String;
  code?: String;
  establishmentDate?: DateTimeOutput;
  representative?: String;
  BusinessScope?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  code: () => Promise<String>;
  establishmentDate: () => Promise<DateTimeOutput>;
  representative: () => Promise<String>;
  location: <T = LocationPromise>() => T;
  BusinessScope: () => Promise<String>;
  works: <T = FragmentableArray<Work>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  code: () => Promise<AsyncIterator<String>>;
  establishmentDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  representative: () => Promise<AsyncIterator<String>>;
  location: <T = LocationSubscription>() => T;
  BusinessScope: () => Promise<AsyncIterator<String>>;
  works: <T = Promise<AsyncIterator<WorkSubscription>>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LocationEdge {
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface AggregateFamily {
  count: Int;
}

export interface AggregateFamilyPromise
  extends Promise<AggregateFamily>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFamilySubscription
  extends Promise<AsyncIterator<AggregateFamily>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationPreviousValues {
  id: ID_Output;
  name?: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface FamilyConnection {}

export interface FamilyConnectionPromise
  extends Promise<FamilyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FamilyEdge>>() => T;
  aggregate: <T = AggregateFamilyPromise>() => T;
}

export interface FamilyConnectionSubscription
  extends Promise<AsyncIterator<FamilyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FamilyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFamilySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CompanyEdge {
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MajorSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface MajorSubscriptionPayloadPromise
  extends Promise<MajorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MajorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MajorPreviousValuesPromise>() => T;
}

export interface MajorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MajorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MajorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MajorPreviousValuesSubscription>() => T;
}

export interface AggregateCollegeEntranceExam {
  count: Int;
}

export interface AggregateCollegeEntranceExamPromise
  extends Promise<AggregateCollegeEntranceExam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCollegeEntranceExamSubscription
  extends Promise<AsyncIterator<AggregateCollegeEntranceExam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MajorPreviousValues {
  id: ID_Output;
  name: String;
  category: String;
  education: Educationkind;
}

export interface MajorPreviousValuesPromise
  extends Promise<MajorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<String>;
  education: () => Promise<Educationkind>;
}

export interface MajorPreviousValuesSubscription
  extends Promise<AsyncIterator<MajorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<String>>;
  education: () => Promise<AsyncIterator<Educationkind>>;
}

export interface CollegeEntranceExamConnection {}

export interface CollegeEntranceExamConnectionPromise
  extends Promise<CollegeEntranceExamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CollegeEntranceExamEdge>>() => T;
  aggregate: <T = AggregateCollegeEntranceExamPromise>() => T;
}

export interface CollegeEntranceExamConnectionSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CollegeEntranceExamEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCollegeEntranceExamSubscription>() => T;
}

export interface School {
  id: ID_Output;
  name?: String;
  kind?: Educationkind;
}

export interface SchoolPromise extends Promise<School>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  kind: () => Promise<Educationkind>;
  location: <T = LocationPromise>() => T;
}

export interface SchoolSubscription
  extends Promise<AsyncIterator<School>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  kind: () => Promise<AsyncIterator<Educationkind>>;
  location: <T = LocationSubscription>() => T;
}

export interface Person {
  id: ID_Output;
  name: String;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  user: <T = UserPromise>() => T;
  families: <T = FragmentableArray<Family>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  families: <T = Promise<AsyncIterator<FamilySubscription>>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface AggregateVillage {
  count: Int;
}

export interface AggregateVillagePromise
  extends Promise<AggregateVillage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVillageSubscription
  extends Promise<AsyncIterator<AggregateVillage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PersonPreviousValues {
  id: ID_Output;
  name: String;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VillagePreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface VillagePreviousValuesPromise
  extends Promise<VillagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface VillagePreviousValuesSubscription
  extends Promise<AsyncIterator<VillagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UniversityConnection {}

export interface UniversityConnectionPromise
  extends Promise<UniversityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UniversityEdge>>() => T;
  aggregate: <T = AggregateUniversityPromise>() => T;
}

export interface UniversityConnectionSubscription
  extends Promise<AsyncIterator<UniversityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UniversityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUniversitySubscription>() => T;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface AggregateSchoolEdu {
  count: Int;
}

export interface AggregateSchoolEduPromise
  extends Promise<AggregateSchoolEdu>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSchoolEduSubscription
  extends Promise<AsyncIterator<AggregateSchoolEdu>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isPublished: Boolean;
  title: String;
  content: String;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  isPublished: () => Promise<Boolean>;
  title: () => Promise<String>;
  content: () => Promise<String>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isPublished: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface SchoolEdge {
  cursor: String;
}

export interface SchoolEdgePromise extends Promise<SchoolEdge>, Fragmentable {
  node: <T = SchoolPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SchoolEdgeSubscription
  extends Promise<AsyncIterator<SchoolEdge>>,
    Fragmentable {
  node: <T = SchoolSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AreaEdge {
  cursor: String;
}

export interface AreaEdgePromise extends Promise<AreaEdge>, Fragmentable {
  node: <T = AreaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AreaEdgeSubscription
  extends Promise<AsyncIterator<AreaEdge>>,
    Fragmentable {
  node: <T = AreaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RegStatusConnection {}

export interface RegStatusConnectionPromise
  extends Promise<RegStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegStatusEdge>>() => T;
  aggregate: <T = AggregateRegStatusPromise>() => T;
}

export interface RegStatusConnectionSubscription
  extends Promise<AsyncIterator<RegStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegStatusSubscription>() => T;
}

export interface ProvinceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ProvinceSubscriptionPayloadPromise
  extends Promise<ProvinceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProvincePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProvincePreviousValuesPromise>() => T;
}

export interface ProvinceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProvinceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProvinceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProvincePreviousValuesSubscription>() => T;
}

export interface ProvinceConnection {}

export interface ProvinceConnectionPromise
  extends Promise<ProvinceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProvinceEdge>>() => T;
  aggregate: <T = AggregateProvincePromise>() => T;
}

export interface ProvinceConnectionSubscription
  extends Promise<AsyncIterator<ProvinceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProvinceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProvinceSubscription>() => T;
}

export interface ProvincePreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface ProvincePreviousValuesPromise
  extends Promise<ProvincePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface ProvincePreviousValuesSubscription
  extends Promise<AsyncIterator<ProvincePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface PostConnection {}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface Location {
  id: ID_Output;
  name?: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  province: <T = ProvincePromise>() => T;
  city: <T = CityPromise>() => T;
  area: <T = AreaPromise>() => T;
  street: <T = StreetPromise>() => T;
  village: <T = VillagePromise>() => T;
  schools: <T = FragmentableArray<School>>(
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  companies: <T = FragmentableArray<Company>>(
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  universities: <T = FragmentableArray<University>>(
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  people: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  province: <T = ProvinceSubscription>() => T;
  city: <T = CitySubscription>() => T;
  area: <T = AreaSubscription>() => T;
  street: <T = StreetSubscription>() => T;
  village: <T = VillageSubscription>() => T;
  schools: <T = Promise<AsyncIterator<SchoolSubscription>>>(
    args?: {
      where?: SchoolWhereInput;
      orderBy?: SchoolOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  universities: <T = Promise<AsyncIterator<UniversitySubscription>>>(
    args?: {
      where?: UniversityWhereInput;
      orderBy?: UniversityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  people: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Province {
  id: ID_Output;
  code: String;
  name: String;
}

export interface ProvincePromise extends Promise<Province>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
  cities: <T = FragmentableArray<City>>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ProvinceSubscription
  extends Promise<AsyncIterator<Province>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  cities: <T = Promise<AsyncIterator<CitySubscription>>>(
    args?: {
      where?: CityWhereInput;
      orderBy?: CityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RegStatusSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface RegStatusSubscriptionPayloadPromise
  extends Promise<RegStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegStatusPreviousValuesPromise>() => T;
}

export interface RegStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegStatusPreviousValuesSubscription>() => T;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegStatusPreviousValues {
  id: ID_Output;
}

export interface RegStatusPreviousValuesPromise
  extends Promise<RegStatusPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface RegStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<RegStatusPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface FamilyEdge {
  cursor: String;
}

export interface FamilyEdgePromise extends Promise<FamilyEdge>, Fragmentable {
  node: <T = FamilyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FamilyEdgeSubscription
  extends Promise<AsyncIterator<FamilyEdge>>,
    Fragmentable {
  node: <T = FamilySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VillageSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface VillageSubscriptionPayloadPromise
  extends Promise<VillageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VillagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VillagePreviousValuesPromise>() => T;
}

export interface VillageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VillageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VillageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VillagePreviousValuesSubscription>() => T;
}

export interface CompanyConnection {}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface SchoolSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SchoolSubscriptionPayloadPromise
  extends Promise<SchoolSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolPreviousValuesPromise>() => T;
}

export interface SchoolSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolPreviousValuesSubscription>() => T;
}

export interface SchoolEdu {
  id: ID_Output;
  startTime?: DateTimeOutput;
  grade?: Int;
  className?: String;
}

export interface SchoolEduPromise extends Promise<SchoolEdu>, Fragmentable {
  id: () => Promise<ID_Output>;
  school: <T = SchoolPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  major: <T = MajorPromise>() => T;
  grade: () => Promise<Int>;
  className: () => Promise<String>;
  students: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SchoolEduSubscription
  extends Promise<AsyncIterator<SchoolEdu>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  school: <T = SchoolSubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  major: <T = MajorSubscription>() => T;
  grade: () => Promise<AsyncIterator<Int>>;
  className: () => Promise<AsyncIterator<String>>;
  students: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SchoolPreviousValues {
  id: ID_Output;
  name?: String;
  kind?: Educationkind;
}

export interface SchoolPreviousValuesPromise
  extends Promise<SchoolPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  kind: () => Promise<Educationkind>;
}

export interface SchoolPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  kind: () => Promise<AsyncIterator<Educationkind>>;
}

export interface VillageConnection {}

export interface VillageConnectionPromise
  extends Promise<VillageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VillageEdge>>() => T;
  aggregate: <T = AggregateVillagePromise>() => T;
}

export interface VillageConnectionSubscription
  extends Promise<AsyncIterator<VillageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VillageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVillageSubscription>() => T;
}

export interface User {
  id: ID_Output;
  username: String;
  password: String;
  name?: String;
  gender?: String;
  avatar?: String;
  birthdaycalendar?: String;
  birthday?: DateTimeOutput;
  uid: String;
  token: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
  gender: () => Promise<String>;
  avatar: () => Promise<String>;
  birthdaycalendar: () => Promise<String>;
  birthday: () => Promise<DateTimeOutput>;
  birthplace: <T = LocationPromise>() => T;
  uid: () => Promise<String>;
  token: () => Promise<String>;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  regStatus: <T = RegStatusPromise>() => T;
  families: <T = FragmentableArray<Family>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  studies: <T = FragmentableArray<SchoolEdu>>(
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  works: <T = FragmentableArray<Work>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  birthdaycalendar: () => Promise<AsyncIterator<String>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  birthplace: <T = LocationSubscription>() => T;
  uid: () => Promise<AsyncIterator<String>>;
  token: () => Promise<AsyncIterator<String>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  regStatus: <T = RegStatusSubscription>() => T;
  families: <T = Promise<AsyncIterator<FamilySubscription>>>(
    args?: {
      where?: FamilyWhereInput;
      orderBy?: FamilyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  studies: <T = Promise<AsyncIterator<SchoolEduSubscription>>>(
    args?: {
      where?: SchoolEduWhereInput;
      orderBy?: SchoolEduOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  works: <T = Promise<AsyncIterator<WorkSubscription>>>(
    args?: {
      where?: WorkWhereInput;
      orderBy?: WorkOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StreetEdge {
  cursor: String;
}

export interface StreetEdgePromise extends Promise<StreetEdge>, Fragmentable {
  node: <T = StreetPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StreetEdgeSubscription
  extends Promise<AsyncIterator<StreetEdge>>,
    Fragmentable {
  node: <T = StreetSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SchoolEduSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SchoolEduSubscriptionPayloadPromise
  extends Promise<SchoolEduSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SchoolEduPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchoolEduPreviousValuesPromise>() => T;
}

export interface SchoolEduSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SchoolEduSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SchoolEduSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchoolEduPreviousValuesSubscription>() => T;
}

export interface AggregateRegStatus {
  count: Int;
}

export interface AggregateRegStatusPromise
  extends Promise<AggregateRegStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegStatusSubscription
  extends Promise<AsyncIterator<AggregateRegStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchoolEduPreviousValues {
  id: ID_Output;
  startTime?: DateTimeOutput;
  grade?: Int;
  className?: String;
}

export interface SchoolEduPreviousValuesPromise
  extends Promise<SchoolEduPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  startTime: () => Promise<DateTimeOutput>;
  grade: () => Promise<Int>;
  className: () => Promise<String>;
}

export interface SchoolEduPreviousValuesSubscription
  extends Promise<AsyncIterator<SchoolEduPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  grade: () => Promise<AsyncIterator<Int>>;
  className: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CityEdge {
  cursor: String;
}

export interface CityEdgePromise extends Promise<CityEdge>, Fragmentable {
  node: <T = CityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CityEdgeSubscription
  extends Promise<AsyncIterator<CityEdge>>,
    Fragmentable {
  node: <T = CitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MajorEdge {
  cursor: String;
}

export interface MajorEdgePromise extends Promise<MajorEdge>, Fragmentable {
  node: <T = MajorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MajorEdgeSubscription
  extends Promise<AsyncIterator<MajorEdge>>,
    Fragmentable {
  node: <T = MajorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StreetSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface StreetSubscriptionPayloadPromise
  extends Promise<StreetSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StreetPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StreetPreviousValuesPromise>() => T;
}

export interface StreetSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StreetSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StreetSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StreetPreviousValuesSubscription>() => T;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StreetPreviousValues {
  id: ID_Output;
  code: String;
  name: String;
}

export interface StreetPreviousValuesPromise
  extends Promise<StreetPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  name: () => Promise<String>;
}

export interface StreetPreviousValuesSubscription
  extends Promise<AsyncIterator<StreetPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface WorkEdge {
  cursor: String;
}

export interface WorkEdgePromise extends Promise<WorkEdge>, Fragmentable {
  node: <T = WorkPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WorkEdgeSubscription
  extends Promise<AsyncIterator<WorkEdge>>,
    Fragmentable {
  node: <T = WorkSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CollegeEntranceExam {
  id: ID_Output;
  subject: String;
  culscore: Float;
  proscore?: Float;
  candidatenum: String;
  times?: Int;
}

export interface CollegeEntranceExamPromise
  extends Promise<CollegeEntranceExam>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  province: <T = ProvincePromise>() => T;
  subject: () => Promise<String>;
  culscore: () => Promise<Float>;
  proscore: () => Promise<Float>;
  candidatenum: () => Promise<String>;
  times: () => Promise<Int>;
  student: <T = UserPromise>() => T;
}

export interface CollegeEntranceExamSubscription
  extends Promise<AsyncIterator<CollegeEntranceExam>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  province: <T = ProvinceSubscription>() => T;
  subject: () => Promise<AsyncIterator<String>>;
  culscore: () => Promise<AsyncIterator<Float>>;
  proscore: () => Promise<AsyncIterator<Float>>;
  candidatenum: () => Promise<AsyncIterator<String>>;
  times: () => Promise<AsyncIterator<Int>>;
  student: <T = UserSubscription>() => T;
}

export interface SchoolEduConnection {}

export interface SchoolEduConnectionPromise
  extends Promise<SchoolEduConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SchoolEduEdge>>() => T;
  aggregate: <T = AggregateSchoolEduPromise>() => T;
}

export interface SchoolEduConnectionSubscription
  extends Promise<AsyncIterator<SchoolEduConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SchoolEduEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSchoolEduSubscription>() => T;
}

export interface PersonEdge {
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateCity {
  count: Int;
}

export interface AggregateCityPromise
  extends Promise<AggregateCity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCitySubscription
  extends Promise<AsyncIterator<AggregateCity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UniversityPreviousValues {
  id: ID_Output;
  name: String;
}

export interface UniversityPreviousValuesPromise
  extends Promise<UniversityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface UniversityPreviousValuesSubscription
  extends Promise<AsyncIterator<UniversityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UniversitySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UniversitySubscriptionPayloadPromise
  extends Promise<UniversitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UniversityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UniversityPreviousValuesPromise>() => T;
}

export interface UniversitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UniversitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UniversitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UniversityPreviousValuesSubscription>() => T;
}

export interface LocationConnection {}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface AggregateProvince {
  count: Int;
}

export interface AggregateProvincePromise
  extends Promise<AggregateProvince>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProvinceSubscription
  extends Promise<AsyncIterator<AggregateProvince>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUniversity {
  count: Int;
}

export interface AggregateUniversityPromise
  extends Promise<AggregateUniversity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUniversitySubscription
  extends Promise<AsyncIterator<AggregateUniversity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CollegeEntranceExamEdge {
  cursor: String;
}

export interface CollegeEntranceExamEdgePromise
  extends Promise<CollegeEntranceExamEdge>,
    Fragmentable {
  node: <T = CollegeEntranceExamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CollegeEntranceExamEdgeSubscription
  extends Promise<AsyncIterator<CollegeEntranceExamEdge>>,
    Fragmentable {
  node: <T = CollegeEntranceExamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "Area",
    embedded: false
  },
  {
    name: "City",
    embedded: false
  },
  {
    name: "CollegeEntranceExam",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Educationkind",
    embedded: false
  },
  {
    name: "Family",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "Major",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Province",
    embedded: false
  },
  {
    name: "RegStatus",
    embedded: false
  },
  {
    name: "School",
    embedded: false
  },
  {
    name: "SchoolEdu",
    embedded: false
  },
  {
    name: "Street",
    embedded: false
  },
  {
    name: "University",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Village",
    embedded: false
  },
  {
    name: "Work",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
